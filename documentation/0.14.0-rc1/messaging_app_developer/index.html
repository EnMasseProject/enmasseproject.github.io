<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Connecting applications to EnMasse</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://enmasse.io/documentation/0.14.0-rc1/messaging_app_developer/">
  <link rel="alternate" type="application/rss+xml" title="EnMasse - Messaging as a Service" href="/feed.xml">
  
  
</head>


  <body>
    <div id="rhbar" style="height:40px;background-color: #202020">
        <a class="rhd-logo" href="http://developers.redhat.com" style="float: right;background-image: url(http://static.jboss.org/images/rhbar/rhd_reverse.png);background-repeat: no-repeat;height: 40px;width: 136px;"></a>
        <a class="rhlogo" href="http://www.redhat.com/" style="float: right;background-image: url(http://static.jboss.org/images/rhbar/redhatlogo_reverse.png);background-repeat: no-repeat;height: 40px;width: 85px;"></a>
    </div>


    <div align="center">
    <br />
    <img alt="EnMasse"
    src="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/images/logo/enmasse_logo.png" height="30%" width="30%" />
</div>
<br />
<br />
<center>
<header align="center" style="align: center;">
  <nav>
    
    

<a href="/" title="Go to Overview">Overview</a> 

 |


<a href="/documentation" title="Go to Documentation">Documentation</a> 

 |


<a href="https://github.com/EnMasseProject/enmasse/releases/" title="Go to Downloads">Downloads</a> 

 |


<a href="/contributing" title="Go to Contributing">Contributing</a> 




  </nav>
</header>
</center>



    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h2> Documentation for EnMasse 0.14.0-rc1 </h2>
        <header align="left">
  <nav>
    
    
  <a href="/documentation/0.14.0-rc1/getting_started" title="Go to Getting Started">Getting Started</a><br />

  <a href="/documentation/0.14.0-rc1/service_admin" title="Go to Installation and configuration">Installation and configuration</a><br />

  <a href="/documentation/0.14.0-rc1/tenant" title="Go to Managing address spaces and addresses">Managing address spaces and addresses</a><br />

  <a href="/documentation/0.14.0-rc1/messaging_app_developer" title="Go to Connecting applications to EnMasse">Connecting applications to EnMasse</a><br />


  </nav>
</header>

        <br />
        <h3> Connecting applications to EnMasse </h3>
        <br />
        <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#address_model">1. Address Model</a>
<ul class="sectlevel3">
<li><a href="#address_space">1.1. Address Space</a></li>
<li><a href="#address">1.2. Address</a></li>
<li><a href="#plans">1.3. Plans</a>
<ul class="sectlevel4">
<li><a href="#address_space_plans">Address Space Plans</a></li>
<li><a href="#address_plans">Address Plans</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#address_space_2">2. Address Space</a>
<ul class="sectlevel3">
<li><a href="#standard_address_space">2.1. Standard Address Space</a>
<ul class="sectlevel4">
<li><a href="#address_types">Address Types</a></li>
<li><a href="#standard-queue">Queue</a></li>
<li><a href="#standard-topic">Topic</a></li>
<li><a href="#anycast">Anycast</a></li>
<li><a href="#multicast">Multicast</a></li>
</ul>
</li>
<li><a href="#brokered_address_space">2.2. Brokered Address Space</a>
<ul class="sectlevel4">
<li><a href="#address_types_2">Address types</a></li>
<li><a href="#brokered-queue">Queue</a></li>
<li><a href="#brokered-topic">Topic</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#connecting">3. Connecting to EnMasse</a>
<ul class="sectlevel3">
<li><a href="#client_examples">3.1. Client Examples</a>
<ul class="sectlevel4">
<li><a href="#apache_qpid_proton_python">Apache Qpid Proton Python</a></li>
<li><a href="#apache_qpid_jms">Apache Qpid JMS</a></li>
<li><a href="#rhea_javascript_client">Rhea JavaScript Client</a></li>
<li><a href="#apache_qpid_proton_c">Apache Qpid Proton C++</a></li>
<li><a href="#amqp_net_lite">AMQP.Net Lite</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="address_model">1. Address Model</h3>
<div class="paragraph">
<p>The EnMasse address model involves three distinct concepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>types of address spaces</p>
</li>
<li>
<p>types of addresses within each address space</p>
</li>
<li>
<p>available plans</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="address_space">1.1. Address Space</h4>
<div class="paragraph">
<p>An address space is a group of addresses that can be accessed through a single connection (per protocol). This means that clients connected to the endpoints of an address space can send messages to or receive messages from any address it is authorized to send messages to or receive messages from within that address space. An address space can support multiple protocols, which is defined by the address space type.</p>
</div>
</div>
<div class="sect3">
<h4 id="address">1.2. Address</h4>
<div class="paragraph">
<p>An address is part of an address space and represents a destination used for sending and receiving messages. An address has a type, which defines the semantics of sending messages to and receiving messages from that address.</p>
</div>
</div>
<div class="sect3">
<h4 id="plans">1.3. Plans</h4>
<div class="paragraph">
<p>Both address spaces and addresses can be restricted by a plan, which enforces a limit on resource usage across multiple dimensions. &lt;tag for upstream only&gt;Note that the set of plans currently offered might be extended in the future, and the constraints imposed by a plan within an address space might change as operational experience is gained.&lt;/tag for upstream only&gt;</p>
</div>
<div class="sect4">
<h5 id="address_space_plans">Address Space Plans</h5>
<div class="paragraph">
<p>Each address space has a plan that restricts the aggregated resource usage within an address space. Each address space type can translate the plan into a set of restrictions, for example, the ability to scale up to five routers or to create up to 10 addresses. These restrictions are documented within each address space.</p>
</div>
</div>
<div class="sect4">
<h5 id="address_plans">Address Plans</h5>
<div class="paragraph">
<p>The usage of each address is also constrained by a plan. Each address type translates the plan into a set of restrictions, for example, up to five consumers or up to 100 messages per hour. These restrictions are documented within each address type.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="address_space_2">2. Address Space</h3>
<div class="paragraph">
<p>The only currently supported address space is standard.</p>
</div>
<div class="sect3">
<h4 id="standard_address_space">2.1. Standard Address Space</h4>
<div class="paragraph">
<p>The default address space in EnMasse is the standard address space and it consists of an AMQP router network in combination with attachable storage units. The implementation of a storage unit is hidden from the client and the routers with a well-defined API. This address space type is appropriate when you have many connections and addresses. However, it has the following limitations: no transaction support, no message ordering, no selectors on queues, and no message groups.</p>
</div>
<div class="paragraph">
<p>Clients connect and send and receive messages in this address space using the AMQP or MQTT protocols. Note that MQTT does not support qos2 or retained messages.</p>
</div>
<div class="sect4">
<h5 id="address_types">Address Types</h5>
<div class="paragraph">
<p>The standard address space supports four address types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>queue</p>
</li>
<li>
<p>topic</p>
</li>
<li>
<p>anycast</p>
</li>
<li>
<p>multicast</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="standard-queue">Queue</h5>
<div class="paragraph">
<p>The queue address type is a store-and-forward queue. This address type is appropriate for implementing a distributed work queue, handling traffic bursts, and other use cases where you want to decouple the producer and consumer. A queue can be sharded across multiple storage units, in which case message order is no longer guaranteed.</p>
</div>
<div class="sect5">
<h6 id="queue-plans">Queue Plans</h6>
<div class="ulist">
<ul>
<li>
<p>inmemory</p>
</li>
<li>
<p>persisted</p>
</li>
<li>
<p>pooled-inmemory</p>
</li>
<li>
<p>pooled-persisted</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="in-memory-queue">In memory</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for queues. Messages are not persisted on
stable storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="persisted-queue">Persisted</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for queues. Messages are persisted on stable
storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="pooled-in-memory-queue">Pooled in memory</h7>
<div class="paragraph">
<p>Schedules queues to run on a shared broker cluster, reducing overhead. Messages
are not persisted on stable storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="pooled-persisted-queue">Pooled persisted</h7>
<div class="paragraph">
<p>Schedules queues to run on a shared broker cluster, reducing overhead. Messages
are persisted on stable storage.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="standard-topic">Topic</h5>
<div class="paragraph">
<p>The topic address type supports the publish-subscribe messaging pattern where you have 1..N producers and 1..M consumers. Each message published to a topic address is forwarded to all subscribers for that address. A subscriber can also be durable, in which case messages are kept until the subscriber has acknowledged them.</p>
</div>
<div class="sect5">
<h6 id="topic-plans">Topic Plans</h6>
<div class="ulist">
<ul>
<li>
<p>inmemory</p>
</li>
<li>
<p>persisted</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="in-memory-topic">In memory</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for topics. Messages are not persisted on
stable storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="persisted-topic">Persisted</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for topics. Messages are persisted on stable
storage.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="anycast">Anycast</h5>
<div class="paragraph">
<p>The anycast address type is a scalable direct address for sending messages to one consumer. Messages sent to an anycast address are not stored, but forwarded directly to the consumer. This method makes this address type ideal for request-reply (RPC) uses or even work distribution. This is the cheapest address type as it does not require any persistence.</p>
</div>
<div class="sect5">
<h6 id="anycast-plans">Anycast Plans</h6>
<div class="ulist">
<ul>
<li>
<p>standard</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="multicast">Multicast</h5>
<div class="paragraph">
<p>The multicast address type is a scalable direct address for sending messages to multiple consumers. Messages sent to a multicast address are forwarded to all consumers receiving messages on that address. It is important to note that only pre-settled messages can be sent to multicast addresses, as message acknowledgements from consumers are not propagated to producers.</p>
</div>
<div class="sect5">
<h6 id="multicast-plans">Multicast Plans</h6>
<div class="ulist">
<ul>
<li>
<p>standard</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="brokered_address_space">2.2. Brokered Address Space</h4>
<div class="paragraph">
<p>The brokered address space is designed to support broker-specific features, at the cost of limited
scale in terms of the number of connections and addresses. This address space supports JMS
transactions, message groups, and so on.</p>
</div>
<div class="paragraph">
<p>Clients connect and send and receive messages in this address space using the AMQP protocol.</p>
</div>
<div class="sect4">
<h5 id="address_types_2">Address types</h5>
<div class="ulist">
<ul>
<li>
<p>queue</p>
</li>
<li>
<p>topic</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="brokered-queue">Queue</h5>
<div class="paragraph">
<p>The queue address type is a store-and-forward queue. This address type is appropriate for
implementing a distributed work queue, handling traffic bursts, and other use cases where you want
to decouple the producer and consumer. A queue in the brokered address spaces supports selectors,
message groups, transactions and other JMS features. If the queue is a high volume queue and these
semantics are not needed, see the <a href="#standard-queue">standard address space <code>queue</code></a> type.</p>
</div>
<div class="sect5">
<h6 id="brokered-queue-plans">Queue Plans</h6>
<div class="ulist">
<ul>
<li>
<p>standard</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="standard-queue-plan">Standard</h7>
<div class="paragraph">
<p>The standard queue plan deploys a queue in the broker for that address space.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="brokered-topic">Topic</h5>
<div class="paragraph">
<p>The topic address type supports the publish-subscribe messaging pattern where you have 1..N producers and 1..M consumers. Each message published to a topic address is forwarded to all subscribers for that address. A subscriber can also be durable, in which case messages are kept until the subscriber has acknowledged them.</p>
</div>
<div class="sect5">
<h6 id="brokered-topic-plans">Topic Plans</h6>
<div class="ulist">
<ul>
<li>
<p>standard</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="standard-topic-plan">Standard</h7>
<div class="paragraph">
<p>The standard topic plan deploys a topic in the broker for that address space.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="connecting">3. Connecting to EnMasse</h3>
<div class="paragraph">
<p>To connect to the messaging service from outside the openshift or
kubernetes cluster, TLS must be used with SNI set to specify the fully
qualified hostname for the address-space. The port used is 443.</p>
</div>
<div class="paragraph">
<p>The messaging protocols supported depends on the type of the
address-space. At present AMQP and MQTT are supported.</p>
</div>
<div class="paragraph">
<p>TODO: Add information about retrieving the CA certificate and using
that in the client examples.</p>
</div>
<div class="paragraph">
<p>TODO: Add information about authentication.</p>
</div>
<div class="sect3">
<h4 id="client_examples">3.1. Client Examples</h4>
<div class="paragraph">
<p>Simple examples are shown here for the following clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Qpid Proton Python</p>
</li>
<li>
<p>Apache Qpid JMS</p>
</li>
<li>
<p>Rhea JavaScript Client</p>
</li>
<li>
<p>Apache Qpid Proton C++</p>
</li>
<li>
<p>AMQP.Net Lite</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These all assume you have created an address of type 'queue' named
'myqueue'.</p>
</div>
<div class="paragraph">
<p>TODO: add links for all these clients</p>
</div>
<div class="sect4">
<h5 id="apache_qpid_proton_python">Apache Qpid Proton Python</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>from __future__ import print_function, unicode_literals
from proton import Message
from proton.handlers import MessagingHandler
from proton.reactor import Container

class HelloWorld(MessagingHandler):
    def __init__(self, server, address):
        super(HelloWorld, self).__init__()
        self.server = server
        self.address = address

    def on_start(self, event):
        conn = event.container.connect(self.server)
        event.container.create_receiver(conn, self.address)
        event.container.create_sender(conn, self.address)

    def on_sendable(self, event):
        event.sender.send(Message(body="Hello World!"))
        event.sender.close()

    def on_message(self, event):
        print(event.message.body)
        event.connection.close()

Container(HelloWorld("amqps://messaging-enmasse-1504862365.10.19.44.61.nip.io:443", "myqueue")).run()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="apache_qpid_jms">Apache Qpid JMS</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>package org.apache.qpid.jms.example;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.DeliveryMode;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageProducer;
import javax.jms.Session;
import javax.jms.TextMessage;
import javax.naming.Context;
import javax.naming.InitialContext;

public class HelloWorld {
    public static void main(String[] args) throws Exception {
        try {
            // The configuration for the Qpid InitialContextFactory has been supplied in
            // a jndi.properties file in the classpath, which results in it being picked
            // up automatically by the InitialContext constructor.
            Context context = new InitialContext();

            ConnectionFactory factory = (ConnectionFactory) context.lookup("myFactoryLookup");
            Destination queue = (Destination) context.lookup("myQueueLookup");

            Connection connection = factory.createConnection(System.getProperty("USER"), System.getProperty("PASSWORD"));
            connection.setExceptionListener(new MyExceptionListener());
            connection.start();

            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

            MessageProducer messageProducer = session.createProducer(queue);
            MessageConsumer messageConsumer = session.createConsumer(queue);

            TextMessage message = session.createTextMessage("Hello world!");
            messageProducer.send(message, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
            TextMessage receivedMessage = (TextMessage) messageConsumer.receive(2000L);

            if (receivedMessage != null) {
                System.out.println(receivedMessage.getText());
            } else {
                System.out.println("No message received within the given timeout!");
            }

            connection.close();
        } catch (Exception exp) {
            System.out.println("Caught exception, exiting.");
            exp.printStackTrace(System.out);
            System.exit(1);
        }
    }

    private static class MyExceptionListener implements ExceptionListener {
        @Override
        public void onException(JMSException exception) {
            System.out.println("Connection ExceptionListener fired, exiting.");
            exception.printStackTrace(System.out);
            System.exit(1);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with jndi.properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>connectionfactory.myFactoryLookup = amqps://messaging-enmasse-1504862365.10.19.44.61.nip.io:443?transport.trustAll=true&amp;transport.verifyHost=false
queue.myQueueLookup = myqueue</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rhea_javascript_client">Rhea JavaScript Client</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>var container = require('rhea');
container.on('connection_open', function (context) {
    context.connection.open_receiver('myqueue');
    context.connection.open_sender('myqueue');
});
container.on('message', function (context) {
    console.log(context.message.body);
    context.connection.close();
});
container.on('sendable', function (context) {
    context.sender.send({body:'Hello World!'});
    context.sender.detach();
});
container.connect({port:443, host:messaging-enmasse-1504862365.10.19.44.61.nip.io, transport:tls, rejectUnauthorized:false});</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="apache_qpid_proton_c">Apache Qpid Proton C++</h5>
<div class="paragraph">
<p>The C client has equivalent simple_recv and simple_send examples with the same options as python. However, the C library does not perform the same level of processing on the URL; in particular it won&#8217;t take amqps:// to imply using TLS, so the example needs to be modified as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#include &lt;proton/connection.hpp&gt;
#include &lt;proton/container.hpp&gt;
#include &lt;proton/default_container.hpp&gt;
#include &lt;proton/delivery.hpp&gt;
#include &lt;proton/message.hpp&gt;
#include &lt;proton/messaging_handler.hpp&gt;
#include &lt;proton/ssl.hpp&gt;
#include &lt;proton/thread_safe.hpp&gt;
#include &lt;proton/tracker.hpp&gt;
#include &lt;proton/url.hpp&gt;

#include &lt;iostream&gt;

#include "fake_cpp11.hpp"

class hello_world : public proton::messaging_handler {
  private:
    proton::url url;

  public:
    hello_world(const std::string&amp; u) : url(u) {}

    void on_container_start(proton::container&amp; c) OVERRIDE {
        proton::connection_options co;
        co.ssl_client_options(proton::ssl_client_options());
        c.client_connection_options(co);
        c.connect(url);
    }

    void on_connection_open(proton::connection&amp; c) OVERRIDE {
        c.open_receiver(url.path());
        c.open_sender(url.path());
    }

    void on_sendable(proton::sender &amp;s) OVERRIDE {
        proton::message m("Hello World!");
        s.send(m);
        s.close();
    }

    void on_message(proton::delivery &amp;d, proton::message &amp;m) OVERRIDE {
        std::cout &lt;&lt; m.body() &lt;&lt; std::endl;
        d.connection().close();
    }
};

int main(int argc, char **argv) {
    try {
        std::string url = argc &gt; 1 ? argv[1] : "messaging-enmasse-1504862365.10.19.44.61.nip.io:443/myqueue";

        hello_world hw(url);
        proton::default_container(hw).run();

        return 0;
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 1;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="amqp_net_lite">AMQP.Net Lite</h5>
<div class="paragraph">
<p>Need Chuck’s help with this</p>
</div>
</div>
</div>
</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">EnMasse - Messaging as a Service</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              EnMasse - Messaging as a Service
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div class="container" id="companyfooter">
      <div class="redhatlogo" style="text-align:center;">
          <div id="logospacer"></div>
          <a href="http://www.redhat.com/"><img alt="Red Hat" src="http://static.jboss.org/images/rhbar/redhatlogo.png"></a>
      </div>
    </div>
  </body>

</html>
