<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Documentation for EnMasse master</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://enmasse.io/documentation/master/">
  <link rel="alternate" type="application/rss+xml" title="EnMasse - Messaging as a Service" href="/feed.xml">
  
  
</head>


  <body>
    <div id="rhbar" style="height:40px;background-color: #202020">
        <a class="rhd-logo" href="http://developers.redhat.com" style="float: right;background-image: url(http://static.jboss.org/images/rhbar/rhd_reverse.png);background-repeat: no-repeat;height: 40px;width: 136px;"></a>
        <a class="rhlogo" href="http://www.redhat.com/" style="float: right;background-image: url(http://static.jboss.org/images/rhbar/redhatlogo_reverse.png);background-repeat: no-repeat;height: 40px;width: 85px;"></a>
    </div>


    <div align="center">
    <br />
    <img alt="EnMasse"
    src="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/images/logo/enmasse_logo.png" height="30%" width="30%" />
</div>
<br />
<br />
<center>
<header align="center" style="align: center;">
  <nav>
    
    

<a href="/" title="Go to Overview">Overview</a> 

 |


<a href="/documentation" title="Go to Documentation">Documentation</a> 

 |


<a href="https://github.com/EnMasseProject/enmasse/releases/" title="Go to Downloads">Downloads</a> 

 |


<a href="/contributing" title="Go to Contributing">Contributing</a> 




  </nav>
</header>
</center>



    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h2> Documentation for EnMasse master </h2>
        <header align="left">
  <nav>
    
    

  </nav>
</header>

        <br />
        <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#installation_and_configuration">1. Installation and configuration</a>
<ul class="sectlevel2">
<li><a href="#installing-openshift">1.1. Installing EnMasse on OpenShift</a></li>
<li><a href="#installing-openshift">1.2. Installing EnMasse on Kubernetes</a></li>
</ul>
</li>
<li><a href="#managing_address_spaces_and_addresses">2. Managing address spaces and addresses</a>
<ul class="sectlevel2">
<li><a href="#address_model">2.1. Address Model</a></li>
<li><a href="#configuring-using-restapi">2.2. Configuring EnMasse using a REST API</a></li>
</ul>
</li>
<li><a href="#connecting_applications_to_enmasse">3. Connecting applications to EnMasse</a>
<ul class="sectlevel2">
<li><a href="#connecting">3.1. Connecting to EnMasse</a></li>
</ul>
</li>
<li><a href="#quick_start_guides">Appendix A: Quick start guides</a>
<ul class="sectlevel3">
<li><a href="#enmasse-on-openshift">A.1. EnMasse on OpenShift</a></li>
<li><a href="#enmasse-on-kubernetes">A.2. EnMasse on Kubernetes</a></li>
<li><a href="#setting-up-enmasse-on-aws">A.3. Setting up EnMasse on AWS</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="installation_and_configuration">1. Installation and configuration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="installing-openshift">1.1. Installing EnMasse on OpenShift</h3>
<div class="sect3">
<h4 id="prerequisites-openshift">1.1.1. Prerequisites</h4>
<div class="paragraph">
<p>To install EnMasse, you need to have the OpenShift client tools. You can download the OpenShift
Origin client from <a href="https://github.com/openshift/origin/releases">OpenShift Origin</a>. EnMasse has
been tested to work with the latest stable release of the OpenShift Origin Client.</p>
</div>
<div class="paragraph">
<p>If you do not have an OpenShift cluster available, see
<a href="https://github.com/minishift/minishift">minishift</a> for an example of how to run a local instance of OpenShift
on your machine.</p>
</div>
<div class="paragraph">
<p>You also need a way to generate certificates. This guide uses <a href="https://www.openssl.org/">OpenSSL</a>.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To simplify deployment, have a look at the <code>deploy-openshift.sh</code> script which should work on Linux
and Mac. You can invoke the deployment script with <code>-h</code> to view a list of options.</p>
</div>
<div class="paragraph">
<p>This guide will walk through the manual deployment procedure and should work on any platform
supporting the OpenShift client.</p>
</div>
<div class="sect4">
<h5 id="creating_project_for_enmasse">Creating project for EnMasse</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create enmasse project:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc new-project enmasse</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="deploying_authentication_services">Deploying authentication services</h5>
<div class="paragraph">
<p>EnMasse require at least 1 authentication service to be deployed. The authentication service
can either be none (allow all), standard (keycloak) or external (not managed by enmasse).</p>
</div>
<div class="sect5">
<h6 id="deploying_the_none_authentication_service">Deploying the none authentication service</h6>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a certificate to use for the none authentication service. For testing purposes, you can create a self-signed certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">mkdir -p none-authservice-cert
openssl req -new -x509 -batch -nodes -days 11000 -subj "/O=io.enmasse/CN=none-authservice.enmasse.svc.cluster.local" -out none-authservice-cert/tls.crt -keyout none-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with the none authentication service certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc create secret tls none-authservice-cert --cert=none-authservice-cert/tls.crt --key=none-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create the none authentication service:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc process -f ./openshift/addons/none-authservice.yaml | oc create -f -</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="deploying_the_standard_authentication_service">Deploying the standard authentication service</h6>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a certificate to use for the standard authentication service. For testing purposes, you can create a self-signed certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">mkdir -p standard-authservice-cert
openssl req -new -x509 -batch -nodes -days 11000 -subj "/O=io.enmasse/CN=standard-authservice.enmasse.svc.cluster.local" -out standard-authservice-cert/tls.crt -keyout standard-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with the standard authentication service certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc create secret tls standard-authservice-cert --cert=standard-authservice-cert/tls.crt --key=standard-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with keycloak admin credentials. Choose password wisely as this user will have complete access over authentication and authorization policies:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc create secret generic keycloak-credentials --from-literal=admin.username=admin --from-literal=admin.password=myrandompassword</pre>
</div>
</div>
</li>
<li>
<p>Give view permissions for the keycloak controller:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc adm add-role-to-user view system:serviceaccount:$(oc project -q):default</pre>
</div>
</div>
</li>
<li>
<p>Create the standard authentication service:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc process -f ./openshift/addons/standard-authservice.yaml | oc create -f -</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect4">
<h5 id="deploying_enmasse">Deploying EnMasse</h5>
<div class="paragraph">
<p>To deploy EnMasse, it is recommended that you have cluster-admin access in order to set up the
required roles for creating namespaces and managing resources in those namespaces. See
<a href="#openshift-install-single-address-space">Procedure</a> for how to deploy EnMasse without cluster-admin
access, which will restrict it to a single address space.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a service account for the EnMasse address controller:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc create sa enmasse-admin</pre>
</div>
</div>
</li>
<li>
<p>Create cluster-wide roles used by the <code>enmasse-admin</code> service account:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc login -u system:admin
oc create -f ./openshift/cluster-roles.yaml</pre>
</div>
</div>
</li>
<li>
<p>Grant cluster-admin privileges to service account:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc login -u system:admin
oc adm policy add-cluster-role-to-user enmasse-namespace-admin system:serviceaccount:enmasse:enmasse-admin</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note</strong>: You can log back in as the regular user after this step.</p>
</div>
</li>
<li>
<p>Create a certificate to use for the address controller. For testing purposes, you can create a self-signed certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">mkdir -p address-controller-cert/
openssl req -new -x509 -batch -nodes -days 11000 -subj "/O=io.enmasse/CN=address-controller.enmasse.svc.cluster.local" -out address-controller-cert/tls.crt -keyout address-controller-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create a secret containing the address-controller certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc create secret tls address-controller-cert --cert=address-controller-cert/tls.crt --key=address-controller-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Deploy the address-controller:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc process -f ./openshift/enmasse.yaml ENABLE_RBAC=true ADDRESS_CONTROLLER_CERT_SECRET=address-controller-cert | oc create -f -</pre>
</div>
</div>
<div class="paragraph">
<p>The deployments required for running EnMasse are now created.</p>
</div>
</li>
<li>
<p>EnMasse will be up and running once all pods in the 'enmasse' namespace are in the <code>Running</code> state:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc get pods -n enmasse</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="deploying_enmasse_limited_to_a_single_address_space">Deploying EnMasse limited to a single address space</h5>
<div id="openshift-install-single-address-space" class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create service accounts for the EnMasse address controller and address space:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc create sa -n enmasse enmasse-admin
oc create sa -n enmasse address-space-admin</pre>
</div>
</div>
</li>
<li>
<p>Grant privileges required for viewing and managing resources:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc policy add-role-to-user view system:serviceaccount:enmasse:default
oc policy add-role-to-user admin system:serviceaccount:enmasse:enmasse-admin
oc policy add-role-to-user admin system:serviceaccount:enmasse:address-space-admin</pre>
</div>
</div>
</li>
<li>
<p>Create a certificate to use for the address controller. For testing purposes, you can create a self-signed certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">mkdir -p address-controller-cert/
openssl req -new -x509 -batch -nodes -days 11000 -subj "/O=io.enmasse/CN=address-controller.enmasse.svc.cluster.local" -out address-controller-cert/tls.crt -keyout address-controller-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with address-controller certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc create secret tls address-controller-cert --cert=address-controller-cert/tls.crt --key=address-controller-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Deploy address-controller:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc process -f ./openshift/enmasse.yaml ENABLE_RBAC=false ADDRESS_CONTROLLER_CERT_SECRET=address-controller-cert | oc create -f -</pre>
</div>
</div>
<div class="paragraph">
<p>The deployments required for running EnMasse are now created.</p>
</div>
</li>
<li>
<p>EnMasse will be up and running once all pods in the 'enmasse' namespace are in the <code>Running</code> state:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">oc get pods -n enmasse</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="installing-openshift">1.2. Installing EnMasse on Kubernetes</h3>
<div class="sect3">
<h4 id="prerequisites-kubernetes">1.2.1. Prerequisites</h4>
<div class="paragraph">
<p>To install EnMasse, you need to have Kubernetes installed. You can use
<a href="https://github.com/kubernetes/minikube">minikube</a> if you want to install EnMasse on your
laptop.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To simplify deployment, have a look at the <code>deploy-kubernetes.sh</code> script which should work on Linux
and Mac. You can invoke the deployment script with <code>-h</code> to view a list of options.</p>
</div>
<div class="paragraph">
<p>This guide will walk through the manual deployment procedure and should work on any platform
supporting the <code>kubectl</code> command line client.</p>
</div>
<div class="sect4">
<h5 id="creating_namespace_for_enmasse">Creating namespace for EnMasse</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create enmasse namespace:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl create namespace enmasse
kubectl config set-context $(kubectl config current-context) --namespace=enmasse</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="deploying_authentication_services_2">Deploying authentication services</h5>
<div class="paragraph">
<p>EnMasse require at least 1 authentication service to be deployed. The authentication service
can either be none (allow all), standard (keycloak) or external (not managed by enmasse).</p>
</div>
<div class="sect5">
<h6 id="deploying_the_none_authentication_service_2">Deploying the none authentication service</h6>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a certificate to use for the none authentication service. For testing purposes, you can create a self-signed certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">mkdir -p none-authservice-cert
openssl req -new -x509 -batch -nodes -days 11000 -subj "/O=io.enmasse/CN=none-authservice.enmasse.svc.cluster.local" -out none-authservice-cert/tls.crt -keyout none-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with the none authentication service certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl create secret tls none-authservice-cert --cert=none-authservice-cert/tls.crt --key=none-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create the none authentication service:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl apply -f ./kubernetes/addons/none-authservice.yaml</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="deploying_the_standard_authentication_service_2">Deploying the standard authentication service</h6>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a certificate to use for the standard authentication service. For testing purposes, you can create a self-signed certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">mkdir -p standard-authservice-cert
openssl req -new -x509 -batch -nodes -days 11000 -subj "/O=io.enmasse/CN=standard-authservice.enmasse.svc.cluster.local" -out standard-authservice-cert/tls.crt -keyout standard-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with the standard authentication service certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl create secret tls standard-authservice-cert --cert=standard-authservice-cert/tls.crt --key=standard-authservice-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with keycloak admin credentials. Choose password wisely as this user will have complete access over authentication and authorization policies:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl create secret generic keycloak-credentials --from-literal=admin.username=admin --from-literal=admin.password=myrandompassword</pre>
</div>
</div>
</li>
<li>
<p>Create the standard authentication service:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl apply -f ./kubernetes/addons/standard-authservice.yaml</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect4">
<h5 id="deploying_enmasse_2">Deploying EnMasse</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create service account for the EnMasse address controller:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl create sa enmasse-admin</pre>
</div>
</div>
</li>
<li>
<p>Create a certificate to use for the address controller. For testing purposes, you can create a self-signed certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">mkdir -p address-controller-cert/
openssl req -new -x509 -batch -nodes -days 11000 -subj "/O=io.enmasse/CN=address-controller.enmasse.svc.cluster.local" -out address-controller-cert/tls.crt -keyout address-controller-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Create secret with address-controller certificate:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl secret tls address-controller-cert --cert=address-controller-cert/tls.crt --key=address-controller-cert/tls.key</pre>
</div>
</div>
</li>
<li>
<p>Deploy address-controller:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl apply -f ./kubernetes/enmasse.yaml</pre>
</div>
</div>
<div class="paragraph">
<p>The deployments required for running EnMasse are now created.</p>
</div>
</li>
<li>
<p>EnMasse will be up and running once all pods in the 'enmasse' namespace are in the <code>Running</code> state:</p>
<div class="listingblock">
<div class="content">
<pre class="nowrap">kubectl get pods -n enmasse</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="managing_address_spaces_and_addresses">2. Managing address spaces and addresses</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="address_model">2.1. Address Model</h3>
<div class="paragraph">
<p>The EnMasse address model involves three distinct concepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>types of address spaces</p>
</li>
<li>
<p>types of addresses within each address space</p>
</li>
<li>
<p>available plans</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="address_space">2.1.1. Address Space</h4>
<div class="paragraph">
<p>An address space is a group of addresses that can be accessed through a single connection (per protocol). This means that clients connected to the endpoints of an address space can send messages to or receive messages from any address it is authorized to send messages to or receive messages from within that address space. An address space can support multiple protocols, which is defined by the address space type.</p>
</div>
</div>
<div class="sect3">
<h4 id="address">2.1.2. Address</h4>
<div class="paragraph">
<p>An address is part of an address space and represents a destination used for sending and receiving messages. An address has a type, which defines the semantics of sending messages to and receiving messages from that address.</p>
</div>
</div>
<div class="sect3">
<h4 id="plans">2.1.3. Plans</h4>
<div class="paragraph">
<p>Both address spaces and addresses can be restricted by a plan, which enforces a limit on resource usage across multiple dimensions. Note that the set of plans currently offered might be extended in the future, and the constraints imposed by a plan within an address space might change as operational experience is gained.</p>
</div>
<div class="sect4">
<h5 id="address_space_plans">Address Space Plans</h5>
<div class="paragraph">
<p>Each address space has a plan that restricts the aggregated resource usage within an address space. Each address space type can translate the plan into a set of restrictions, for example, the ability to scale up to five routers or to create up to 10 addresses. These restrictions are documented within each address space.</p>
</div>
</div>
<div class="sect4">
<h5 id="address_plans">Address Plans</h5>
<div class="paragraph">
<p>The usage of each address is also constrained by a plan. Each address type translates the plan into a set of restrictions, for example, up to five consumers or up to 100 messages per hour. These restrictions are documented within each address type.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="standard_address_space">2.1.4. Standard Address Space</h4>
<div class="paragraph">
<p>The default address space in EnMasse is the standard address space and it consists of an AMQP router network in combination with attachable storage units. The implementation of a storage unit is hidden from the client and the routers with a well-defined API. This address space type is appropriate when you have many connections and addresses. However, it has the following limitations: no transaction support, no message ordering, no selectors on queues, and no message groups.</p>
</div>
<div class="paragraph">
<p>Clients connect and send and receive messages in this address space using the AMQP or MQTT protocols. Note that MQTT does not support qos2 or retained messages.</p>
</div>
<div class="sect4">
<h5 id="address_types">Address Types</h5>
<div class="paragraph">
<p>The standard address space supports four address types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>queue</p>
</li>
<li>
<p>topic</p>
</li>
<li>
<p>anycast</p>
</li>
<li>
<p>multicast</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="standard-queue">Queue</h5>
<div class="paragraph">
<p>The queue address type is a store-and-forward queue. This address type is appropriate for implementing a distributed work queue, handling traffic bursts, and other use cases where you want to decouple the producer and consumer. A queue can be sharded across multiple storage units; however, message order is no longer guaranteed.</p>
</div>
<div class="sect5">
<h6 id="queue-plans">Queue Plans</h6>
<div class="ulist">
<ul>
<li>
<p>inmemory</p>
</li>
<li>
<p>persisted</p>
</li>
<li>
<p>pooled-inmemory</p>
</li>
<li>
<p>pooled-persisted</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="in-memory-queue">In memory</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for queues. Messages are not persisted on
stable storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="persisted-queue">Persisted</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for queues. Messages are persisted on stable
storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="pooled-in-memory-queue">Pooled in memory</h7>
<div class="paragraph">
<p>Schedules queues to run on a shared broker cluster, reducing overhead. Messages
are not persisted on stable storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="pooled-persisted-queue">Pooled persisted</h7>
<div class="paragraph">
<p>Schedules queues to run on a shared broker cluster, reducing overhead. Messages
are persisted on stable storage.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="standard-topic">Topic</h5>
<div class="paragraph">
<p>The topic address type supports the publish-subscribe messaging pattern where you have 1..N producers and 1..M consumers. Each message published to a topic address is forwarded to all subscribers for that address. A subscriber can also be durable, in which case messages are kept until the subscriber has acknowledged them.</p>
</div>
<div class="sect5">
<h6 id="topic-plans">Topic Plans</h6>
<div class="ulist">
<ul>
<li>
<p>inmemory</p>
</li>
<li>
<p>persisted</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="in-memory-topic">In memory</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for topics. Messages are not persisted on
stable storage.</p>
</div>
</div>
<div class="sect6">
<h7 id="persisted-topic">Persisted</h7>
<div class="paragraph">
<p>Creates a standalone broker cluster for topics. Messages are persisted on stable
storage.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="anycast">Anycast</h5>
<div class="paragraph">
<p>The anycast address type is a scalable direct address for sending messages to one consumer. Messages sent to an anycast address are not stored, but forwarded directly to the consumer. This method makes this address type ideal for request-reply (RPC) uses or even work distribution. This is the cheapest address type as it does not require any persistence.</p>
</div>
<div class="sect5">
<h6 id="anycast-plans">Anycast Plans</h6>
<div class="ulist">
<ul>
<li>
<p>standard</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="multicast">Multicast</h5>
<div class="paragraph">
<p>The multicast address type is a scalable direct address for sending messages to multiple consumers. Messages sent to a multicast address are forwarded to all consumers receiving messages on that address. It is important to note that only pre-settled messages can be sent to multicast addresses, as message acknowledgements from consumers are not propagated to producers.</p>
</div>
<div class="sect5">
<h6 id="multicast-plans">Multicast Plans</h6>
<div class="ulist">
<ul>
<li>
<p>standard</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="brokered_address_space">2.1.5. Brokered Address Space</h4>
<div class="paragraph">
<p>The brokered address space is designed to support broker-specific features, at the cost of limited
scale in terms of the number of connections and addresses. This address space supports JMS
transactions, message groups, and so on.</p>
</div>
<div class="paragraph">
<p>Clients connect and send and receive messages in this address space using the AMQP protocol.</p>
</div>
<div class="sect4">
<h5 id="address_types_2">Address types</h5>
<div class="ulist">
<ul>
<li>
<p>queue</p>
</li>
<li>
<p>topic</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="brokered-queue">Queue</h5>
<div class="paragraph">
<p>The queue address type is a store-and-forward queue. This address type is appropriate for
implementing a distributed work queue, handling traffic bursts, and other use cases where you want
to decouple the producer and consumer. A queue in the brokered address spaces supports selectors,
message groups, transactions, and other JMS features.
Only a standard plan is available for queues.</p>
</div>
</div>
<div class="sect4">
<h5 id="brokered-topic">Topic</h5>
<div class="paragraph">
<p>The topic address type supports the publish-subscribe messaging pattern where you have 1..N producers and 1..M consumers. Each message published to a topic address is forwarded to all subscribers for that address. A subscriber can also be durable, in which case messages are kept until the subscriber has acknowledged them.</p>
</div>
<div class="paragraph">
<p>Only a standard plan is available for topics.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-using-restapi">2.2. Configuring EnMasse using a REST API</h3>
<div class="paragraph">
<p>EnMasse provides a REST API that can be used for configuring address spaces and addresses
within those address spaces. When running EnMasse in multitenant mode, clients are
authenticated using <a href="https://kubernetes.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener">RBAC</a> by default.</p>
</div>
<div class="sect3">
<h4 id="creating_an_address_space">2.2.1. Creating an Address Space</h4>
<div class="ulist">
<ul>
<li>
<p>Creating address spaces is only applicable for multitenant deployments of EnMasse.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Save the following JSON data to a file 'space.json':</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>{
    "apiVersion": "v1/enmasse",
    "kind": "AddressSpace",
    "metadata": {
        "name": "myspace"
    },
    "spec": {
        "type": "standard"
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>POST the address space definition to the REST API using curl:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>TOKEN=`oc whoami -t`
curl -X POST -T space.json -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -k https://$(oc get route restapi -o jsonpath='{.spec.host}')/apis/enmasse.io/v1/addressspaces</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will create the infrastructure required for that address space. Starting up the address space
will take a while, usually depending on how fast it is able to download the Docker images for the
various components.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="viewing_address_space_status">2.2.2. Viewing Address Space Status</h4>
<div class="ulist">
<div class="title">Procedure</div>
<ul>
<li>
<p>You can use the REST API to check the status of the address space:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>TOKEN=`oc whoami -t`
curl -k -H "Authorization: Bearer $TOKEN" https://$(oc get route restapi -o jsonpath='{.spec.host}')/apis/enmasse.io/v1/addressspaces/myspace</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can consider the address space to be ready to use when <code>status.isReady</code> is <code>true</code> in the returned JSON
object.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="creating_addresses">2.2.3. Creating Addresses</h4>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>To create addresses in the standard address space, save the following to a file:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>{
  "apiVersion": "enmasse.io/v1",
  "kind": "AddressList",
  "items": [
    {
      "metadata": {
        "name": "myqueue"
      },
      "spec": {
        "type": "queue"
      }
    },
    {
      "metadata": {
        "name": "mytopic"
      },
      "spec": {
        "type": "topic"
      }
    },
    {
      "metadata": {
        "name": "myanycast"
      },
      "spec": {
        "type": "anycast"
      }
    },
    {
      "metadata": {
        "name": "mymulticast"
      },
      "spec": {
        "type": "multicast"
      }
    }
  ]
}</code></pre>
</div>
</div>
</li>
<li>
<p>You can then create those addresses using the following REST API command. Replace <code>default</code> with the name of your address space:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>TOKEN=`oc whoami -t`
curl -X PUT -T addresses.json -H "content-type: application/json" -H "Authorization: Bearer $TOKEN" -k https://$(oc get route restapi -o jsonpath='{.spec.host}')/apis/enmasse.io/v1/addresses/default</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="viewing_configured_addresses">2.2.4. Viewing Configured Addresses</h4>
<div class="ulist">
<div class="title">Procedure</div>
<ul>
<li>
<p>To check which addresses are configured:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>curl -k https://$(oc get route restapi -o jsonpath='{.spec.host}')/apis/enmasse.io/v1/addresses/default</code></pre>
</div>
</div>
<div class="paragraph">
<p>The addresses are ready to be used by messaging clients once the <code>status.isReady</code> field of each
address is set to <code>true</code>.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connecting_applications_to_enmasse">3. Connecting applications to EnMasse</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="connecting">3.1. Connecting to EnMasse</h3>
<div class="paragraph">
<p>To connect to the messaging service from outside the openshift or
kubernetes cluster, TLS must be used with SNI set to specify the fully
qualified hostname for the address-space. The port used is 443.</p>
</div>
<div class="paragraph">
<p>The messaging protocols supported depends on the type of the
address-space.</p>
</div>
<div class="sect3">
<h4 id="client_examples">3.1.1. Client Examples</h4>
<div class="paragraph">
<p>Simple examples are shown here for the following clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Qpid Proton Python</p>
</li>
<li>
<p>Apache Qpid JMS</p>
</li>
<li>
<p>Rhea JavaScript Client</p>
</li>
<li>
<p>Apache Qpid Proton C++</p>
</li>
<li>
<p>AMQP.Net Lite</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These all assume you have created an address of type 'queue' named
'myqueue'.</p>
</div>
<div class="sect4">
<h5 id="apache_qpid_proton_python">Apache Qpid Proton Python</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>from __future__ import print_function, unicode_literals
from proton import Message
from proton.handlers import MessagingHandler
from proton.reactor import Container

class HelloWorld(MessagingHandler):
    def __init__(self, server, address):
        super(HelloWorld, self).__init__()
        self.server = server
        self.address = address

    def on_start(self, event):
        conn = event.container.connect(self.server)
        event.container.create_receiver(conn, self.address)
        event.container.create_sender(conn, self.address)

    def on_sendable(self, event):
        event.sender.send(Message(body="Hello World!"))
        event.sender.close()

    def on_message(self, event):
        print(event.message.body)
        event.connection.close()

Container(HelloWorld("amqps://&lt;messaging-route-hostname&gt;:443", "myqueue")).run()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="apache_qpid_jms">Apache Qpid JMS</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>package org.apache.qpid.jms.example;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.DeliveryMode;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageProducer;
import javax.jms.Session;
import javax.jms.TextMessage;
import javax.naming.Context;
import javax.naming.InitialContext;

public class HelloWorld {
    public static void main(String[] args) throws Exception {
        try {
            // The configuration for the Qpid InitialContextFactory has been supplied in
            // a jndi.properties file in the classpath, which results in it being picked
            // up automatically by the InitialContext constructor.
            Context context = new InitialContext();

            ConnectionFactory factory = (ConnectionFactory) context.lookup("myFactoryLookup");
            Destination queue = (Destination) context.lookup("myQueueLookup");

            Connection connection = factory.createConnection(System.getProperty("USER"), System.getProperty("PASSWORD"));
            connection.setExceptionListener(new MyExceptionListener());
            connection.start();

            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

            MessageProducer messageProducer = session.createProducer(queue);
            MessageConsumer messageConsumer = session.createConsumer(queue);

            TextMessage message = session.createTextMessage("Hello world!");
            messageProducer.send(message, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
            TextMessage receivedMessage = (TextMessage) messageConsumer.receive(2000L);

            if (receivedMessage != null) {
                System.out.println(receivedMessage.getText());
            } else {
                System.out.println("No message received within the given timeout!");
            }

            connection.close();
        } catch (Exception exp) {
            System.out.println("Caught exception, exiting.");
            exp.printStackTrace(System.out);
            System.exit(1);
        }
    }

    private static class MyExceptionListener implements ExceptionListener {
        @Override
        public void onException(JMSException exception) {
            System.out.println("Connection ExceptionListener fired, exiting.");
            exception.printStackTrace(System.out);
            System.exit(1);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with jndi.properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>connectionfactory.myFactoryLookup = amqps://&lt;messaging-route-hostname&gt;:443?transport.trustAll=true&amp;transport.verifyHost=false
queue.myQueueLookup = myqueue</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rhea_javascript_client">Rhea JavaScript Client</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>var container = require('rhea');
container.on('connection_open', function (context) {
    context.connection.open_receiver('myqueue');
    context.connection.open_sender('myqueue');
});
container.on('message', function (context) {
    console.log(context.message.body);
    context.connection.close();
});
container.on('sendable', function (context) {
    context.sender.send({body:'Hello World!'});
    context.sender.detach();
});
container.connect({port:443, host:'&lt;messaging-route-hostname&gt;', transport:'tls', rejectUnauthorized:false});</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="apache_qpid_proton_c">Apache Qpid Proton C++</h5>
<div class="paragraph">
<p>The C client has equivalent simple_recv and simple_send examples with the same options as python. However, the C library does not perform the same level of processing on the URL; in particular it won&#8217;t take amqps:// to imply using TLS, so the example needs to be modified as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#include &lt;proton/connection.hpp&gt;
#include &lt;proton/container.hpp&gt;
#include &lt;proton/default_container.hpp&gt;
#include &lt;proton/delivery.hpp&gt;
#include &lt;proton/message.hpp&gt;
#include &lt;proton/messaging_handler.hpp&gt;
#include &lt;proton/ssl.hpp&gt;
#include &lt;proton/thread_safe.hpp&gt;
#include &lt;proton/tracker.hpp&gt;
#include &lt;proton/url.hpp&gt;

#include &lt;iostream&gt;

#include "fake_cpp11.hpp"

class hello_world : public proton::messaging_handler {
  private:
    proton::url url;

  public:
    hello_world(const std::string&amp; u) : url(u) {}

    void on_container_start(proton::container&amp; c) OVERRIDE {
        proton::connection_options co;
        co.ssl_client_options(proton::ssl_client_options());
        c.client_connection_options(co);
        c.connect(url);
    }

    void on_connection_open(proton::connection&amp; c) OVERRIDE {
        c.open_receiver(url.path());
        c.open_sender(url.path());
    }

    void on_sendable(proton::sender &amp;s) OVERRIDE {
        proton::message m("Hello World!");
        s.send(m);
        s.close();
    }

    void on_message(proton::delivery &amp;d, proton::message &amp;m) OVERRIDE {
        std::cout &lt;&lt; m.body() &lt;&lt; std::endl;
        d.connection().close();
    }
};

int main(int argc, char **argv) {
    try {
        std::string url = argc &gt; 1 ? argv[1] : "&lt;messaging-route-hostname&gt;:443/myqueue";

        hello_world hw(url);
        proton::default_container(hw).run();

        return 0;
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 1;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="amqp_net_lite">AMQP.Net Lite</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>using System;
using Amqp;

namespace Test
{
    public class Program
    {
        public static void Main(string[] args)
        {
            String url = (args.Length &gt; 0) ? args[0] : "amqps://&lt;messaging-route-hostname&gt;:443";
            String address = (args.Length &gt; 1) ? args[1] : "myqueue";

            Connection.DisableServerCertValidation = true;
            Connection connection = new Connection(new Address(url));
            Session session = new Session(connection);
            SenderLink sender = new SenderLink(session, "test-sender", address);

            Message messageSent = new Message("Test Message");
            sender.Send(messageSent);

            ReceiverLink receiver = new ReceiverLink(session, "test-receiver", address);
            Message messageReceived = receiver.Receive(TimeSpan.FromSeconds(2));
            Console.WriteLine(messageReceived.Body);
            receiver.Accept(messageReceived);

            sender.Close();
            receiver.Close();
            session.Close();
            connection.Close();
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quick_start_guides">Appendix A: Quick start guides</h2>
<div class="sectionbody">
<div class="sect3">
<h4 id="enmasse-on-openshift">A.1. EnMasse on OpenShift</h4>
<div class="paragraph">
<p>This guide will walk through the process of setting up EnMasse on
OpenShift with clients for sending and receiving messages. The guide will deploy EnMasse in a single
tenant mode and with the <code>none</code> authentication service.</p>
</div>
<div class="sect4">
<h5 id="prerequisites-openshift">Prerequisites</h5>
<div class="paragraph">
<p>To install EnMasse, you need to have the OpenShift client tools. You can download the OpenShift
Origin client from <a href="https://github.com/openshift/origin/releases">OpenShift Origin</a>. EnMasse has
been tested to work with the latest stable release of the OpenShift Origin Client.</p>
</div>
<div class="paragraph">
<p>If you do not have an OpenShift cluster available, see
<a href="https://github.com/minishift/minishift">minishift</a> for an example of how to run a local instance of OpenShift
on your machine.</p>
</div>
<div class="paragraph">
<p>You also need a way to generate certificates. This guide uses <a href="https://www.openssl.org/">OpenSSL</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="installing-openshift">Installing EnMasse</h5>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This guide uses a shell script for deploying EnMasse. Windows users are adviced to look at
<a href="#installing-openshift">Installing EnMasse on OpenShift</a>.</p>
</div>
<div class="sect5">
<h6 id="deploying_enmasse_3">Deploying EnMasse</h6>
<div class="paragraph">
<p>Invoke the deployment script to deploy EnMasse</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./deploy-openshift.sh -m "https://localhost:8443" -n enmasse </pre>
</div>
</div>
<div class="paragraph">
<p>This will create the deployments required for running EnMasse. Starting
up EnMasse will take a while, usually depending on how fast it is able
to download the docker images for the various components. In the
meantime, you can start to create your address configuration.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="configuring-addresses-openshift">Configuring addresses</h5>
<div class="sect6">
<h7 id="address_types_3">Address types</h7>
<div class="paragraph">
<p>EnMasse is configured with a set of addresses that you can use for
messages. Currently, EnMasse supports 4 different address types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Brokered queues</p>
</li>
<li>
<p>Brokered topics (pub/sub)</p>
</li>
<li>
<p>Direct anycast addresses</p>
</li>
<li>
<p>Direct broadcast addresses</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#address_model">Address Model</a> for details.
EnMasse also comes with a console that you can use for managing
addresses. You can get the console URL by running the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">echo "https://$(oc get route -o jsonpath='{.spec.host}' console)"</pre>
</div>
</div>
<div class="paragraph">
<p>You can also deploy the addressing config using the address controller
API. See the <a href="#configuring-using-restapi">Configuring EnMasse using a REST API</a> for details on the
resources consumed by the API. Here is an example config with all 4 variants that you can save to <code>addresses.json</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">{
  "apiVersion": "enmasse.io/v1",
  "kind": "AddressList",
  "items": [
    {
      "metadata": {
        "name": "myqueue"
      },
      "spec": {
        "type": "queue"
      }
    },
    {
      "metadata": {
        "name": "mytopic"
      },
      "spec": {
        "type": "topic"
      }
    },
    {
      "metadata": {
        "name": "myanycast"
      },
      "spec": {
        "type": "anycast"
      }
    },
    {
      "metadata": {
        "name": "mymulticast"
      },
      "spec": {
        "type": "multicast"
      }
    }
  ]
}</pre>
</div>
</div>
<div class="paragraph">
<p>To deploy this configuration, you must currently use a http client like curl:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">curl -X POST -H "content-type: application/json" --data-binary @addresses.json -k https://$(oc get route -o jsonpath='{.spec.host}' restapi)/apis/enmasse.io/v1/addresses/default</pre>
</div>
</div>
<div class="paragraph">
<p>This will connect to the address controller REST API and deploy the address config.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sending-and-receiving-messages-openshift">Sending and receiving messages</h5>
<div class="sect6">
<h7 id="connecting_with_amqp">Connecting with AMQP</h7>
<div class="paragraph">
<p>For sending and receiving messages, have a look at an example python
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_send.py.html">sender</a>
and
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_recv.py.html">receiver</a>.</p>
</div>
<div class="paragraph">
<p>To send and receive messages, you should connect to the exposed route. To start a receiver, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_recv.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>This will block until it has received 10 messages. To start the sender, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_send.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>The server certificates is not verified in the above examples. To fetch the certificate, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-messaging -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="paragraph">
<p>You can modify the client code to use this cert to verify the server connection.</p>
</div>
<div class="paragraph">
<p>Have a look at <a href="#connecting">Connecting to EnMasse</a> for more client examples.</p>
</div>
</div>
<div class="sect6">
<h7 id="mqtt">Connecting using MQTT</h7>
<div class="paragraph">
<p>For sending and receiving messages route, you can use the paho-mqtt client library. To connect,
fetch the server certificate:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-mqtt  -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="sect7">
<h8 id="subscriber_client">Subscriber client</h8>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_recv.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_recv.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe(opts.topic, int(opts.qos))

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic + " " + str(msg.payload))

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Receive messages from the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("recv")
client.on_connect = on_connect
client.on_message = on_message
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to subscribe to a topic (i.e. <code>mytopic</code> from the previous addresses configuration), the
subscriber client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./tls_mqtt_recv.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt</pre>
</div>
</div>
</div>
<div class="sect7">
<h8 id="publisher_client">Publisher client</h8>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_send.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_send.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.publish(opts.topic, opts.message, int(opts.qos))

def on_publish(client, userdata, mid):
    print("mid: " + str(mid))
    client.disconnect()

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Sends messages to the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

parser.add_option("-m", "--message", default="Hello",
                  help="message to publish (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("send")
client.on_connect = on_connect
client.on_publish = on_publish
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start the publisher, the client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./tls_mqtt_send.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt -m "Hello EnMasse"</pre>
</div>
</div>
<div class="paragraph">
<p>The the publisher publishes the message and disconnects from EnMasse. The message is received by the previous connected subscriber.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="conclusion-openshift">Conclusion</h5>
<div class="paragraph">
<p>We have seen how to setup EnMasse on OpenShift, and how to communicate with it using AMQP and MQTT clients.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enmasse-on-kubernetes">A.2. EnMasse on Kubernetes</h4>
<div class="paragraph">
<p>This guide will walk through the process of setting up EnMasse on a
Kubernetes cluster together with clients for sending and receiving
messages. The guide will deploy EnMasse in a single tenant mode and with the <code>none</code> authentication
service.</p>
</div>
<div class="sect4">
<h5 id="prerequisites-kubernetes">Prerequisites</h5>
<div class="paragraph">
<p>To install EnMasse, you need to have Kubernetes installed. You can use
<a href="https://github.com/kubernetes/minikube">minikube</a> if you want to install EnMasse on your
laptop.</p>
</div>
</div>
<div class="sect4">
<h5 id="installing-kubernetes">Installing</h5>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This guide uses a shell script for deploying EnMasse. Windows users are adviced to look at
<a href="#installing-kubernetes">Installing</a>.</p>
</div>
<div class="sect5">
<h6 id="deploying_enmasse_4">Deploying EnMasse</h6>
<div class="paragraph">
<p>Invoke the deployment script to deploy EnMasse</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./deploy-kubernetes.sh -m "https://localhost:8443" -n enmasse </pre>
</div>
</div>
<div class="paragraph">
<p>This will create the deployments required for running EnMasse. Starting
up EnMasse will take a while, usually depending on how fast it is able
to download the docker images for the various components. In the
meantime, you can start to create your address configuration.</p>
</div>
</div>
<div class="sect5">
<h6 id="role-based-access-control">Role Based Access Control (RBAC)</h6>
<div class="paragraph">
<p>The Kubernetes deployment script and YAML files currently do not support Role
Based Access Control (RBAC). In Kubernetes clusters which have RBAC enabled, it is
required to additionally create a role binding for the <code>default</code> service account
to the <code>view</code> role and for the <code>enmasse-service-account</code> to the <code>cluster-admin</code> role:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">kubectl create clusterrolebinding enmasse-service-account-binding --clusterrole=cluster-admin --serviceaccount=enmasse:enmasse-service-account
kubectl create rolebinding default-view-binding --clusterrole=view --serviceaccount=enmasse:default -n enmasse</pre>
</div>
</div>
<div class="paragraph">
<p><em>Note: The <code>cluster-admin</code> role gives the <code>enmasse-service-account</code> service account unlimited access to the Kubernetes cluster.</em></p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="deploying-external-load-balancers">Deploying external load balancers</h5>
<div class="paragraph">
<p>If you&#8217;re running EnMasse in your own Kubernetes instance on any of the
cloud providers, you can deploy the external load balancer services
to expose EnMasse ports:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">kubectl apply -f kubernetes/addons/external-lb.yaml -n enmasse</pre>
</div>
</div>
<div class="paragraph">
<p>If you are running in multitenant mode, exposing the restapi is sufficient:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">kubectl apply -f kubernetes/addons/external-lb-restapi.yaml -n enmasse</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="configuring-addresses-kubernetes">Configuring addresses</h5>
<div class="sect6">
<h7 id="address_types_4">Address types</h7>
<div class="paragraph">
<p>EnMasse is configured with a set of addresses that you can use for
messages. Currently, EnMasse supports 4 different address types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Brokered queues</p>
</li>
<li>
<p>Brokered topics (pub/sub)</p>
</li>
<li>
<p>Direct anycast addresses</p>
</li>
<li>
<p>Direct broadcast addresses</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#address_model">Address Model</a> for details.
EnMasse also comes with a console that you can use for managing
addresses. You can get the console URL by running the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">echo "https://$(kubectl get ingress -o jsonpath='{.spec.host}' console)"</pre>
</div>
</div>
<div class="paragraph">
<p>You can also deploy the addressing config using the address controller
API. See the <a href="#configuring-using-restapi">Configuring EnMasse using a REST API</a> for details on the
resources consumed by the API. Here is an example config with all 4 variants that you can save to <code>addresses.json</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">{
  "apiVersion": "enmasse.io/v1",
  "kind": "AddressList",
  "items": [
    {
      "metadata": {
        "name": "myqueue"
      },
      "spec": {
        "type": "queue"
      }
    },
    {
      "metadata": {
        "name": "mytopic"
      },
      "spec": {
        "type": "topic"
      }
    },
    {
      "metadata": {
        "name": "myanycast"
      },
      "spec": {
        "type": "anycast"
      }
    },
    {
      "metadata": {
        "name": "mymulticast"
      },
      "spec": {
        "type": "multicast"
      }
    }
  ]
}</pre>
</div>
</div>
<div class="paragraph">
<p>To deploy this configuration, you must currently use a http client like curl:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">curl -X POST -H "content-type: application/json" --data-binary @addresses.json -k https://$(kubectl get ingress -o jsonpath='{.spec.host}' restapi)/apis/enmasse.io/v1/addresses/default</pre>
</div>
</div>
<div class="paragraph">
<p>This will connect to the address controller REST API and deploy the address config.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sending-and-receiving-messages-kubernetes">Sending and receiving messages</h5>
<div class="sect6">
<h7 id="connecting_with_amqp_2">Connecting with AMQP</h7>
<div class="paragraph">
<p>For sending and receiving messages, have a look at an example python
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_send.py.html">sender</a>
and
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_recv.py.html">receiver</a>.</p>
</div>
<div class="paragraph">
<p>To send and receive messages, you should connect to the exposed route. To start a receiver, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_recv.py -a "amqps://$(kubectl get ingress -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>This will block until it has received 10 messages. To start the sender, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_send.py -a "amqps://$(kubectl get ingress -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>The server certificates is not verified in the above examples. To fetch the certificate, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
kubectl get secret external-certs-messaging -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="paragraph">
<p>You can modify the client code to use this cert to verify the server connection.</p>
</div>
<div class="paragraph">
<p>Have a look at <a href="#connecting">Connecting to EnMasse</a> for more client examples.</p>
</div>
</div>
<div class="sect6">
<h7 id="mqtt">Connecting using MQTT</h7>
<div class="paragraph">
<p>For sending and receiving messages route, you can use the paho-mqtt client library. To connect,
fetch the server certificate:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
kubectl get secret external-certs-mqtt  -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="sect7">
<h8 id="subscriber_client_2">Subscriber client</h8>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_recv.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_recv.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe(opts.topic, int(opts.qos))

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic + " " + str(msg.payload))

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Receive messages from the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("recv")
client.on_connect = on_connect
client.on_message = on_message
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to subscribe to a topic (i.e. <code>mytopic</code> from the previous addresses configuration), the
subscriber client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./tls_mqtt_recv.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt</pre>
</div>
</div>
</div>
<div class="sect7">
<h8 id="publisher_client_2">Publisher client</h8>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_send.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_send.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.publish(opts.topic, opts.message, int(opts.qos))

def on_publish(client, userdata, mid):
    print("mid: " + str(mid))
    client.disconnect()

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Sends messages to the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

parser.add_option("-m", "--message", default="Hello",
                  help="message to publish (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("send")
client.on_connect = on_connect
client.on_publish = on_publish
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start the publisher, the client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./tls_mqtt_send.py -c "$(kubectl get ingress -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt -m "Hello EnMasse"</pre>
</div>
</div>
<div class="paragraph">
<p>The the publisher publishes the message and disconnects from EnMasse. The message is received by the previous connected subscriber.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="conclusion-kubernetes">Conclusion</h5>
<div class="paragraph">
<p>We have seen how to setup a messaging service in Kubernetes, and how to
communicate with it using python example AMQP clients.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setting-up-enmasse-on-aws">A.3. Setting up EnMasse on AWS</h4>
<div class="paragraph">
<p>This guide walks you through setting up EnMasse on an AWS EC2 instance.
This is not even very specific to AWS, so you can probably modify the
configuration to fit Microsoft Azure or even Google GCE.</p>
</div>
<div class="paragraph">
<p>The end result from this guide is an instance of EnMasse suitable for
development and/or experimentation, and should not be considered a
production ready setup. For instance, no persistence is configured, so
neither messages in brokers nor state in other components like hawkular
are persisted.</p>
</div>
<div class="sect4">
<h5 id="prerequisites-aws">Prerequisites</h5>
<div class="paragraph">
<p>First, you must have created an <a href="https://aws.amazon.com/ec2/">EC2
instance</a>. EnMasse runs on OpenShift and Kubernetes, but this post uses
OpenShift purely for convenience. Have a look at the
<a href="https://docs.openshift.org/latest/install_config/install/prerequisites.html">OpenShift
prerequisites</a> for the required hardware configuration. The installation
will be done using <a href="https://www.ansible.com">Ansible</a>, so make sure
Ansible is installed on laptop or workstation.</p>
</div>
<div class="sect5">
<h6 id="configure-ansible-to-handle-passwordless-sudo">Configure Ansible to handle passwordless sudo</h6>
<div class="paragraph">
<p>For EC2 instance, the default is a passwordless sudo, and Ansible
(2.3.0.0 at the time of writing) requires a minor configuration
modification to deal with that. On the host you will be running ansible
from, edit /etc/ansible/ansible.cfg, and make sure that the <code>sudo_flags</code>
parameter is set to <code>-H -S</code> (remove the <code>-n</code>).</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="setting-up-openshift-aws">Setting up OpenShift</h5>
<div class="paragraph">
<p>Once Ansible is setup, installing OpenShift is easy. First, an inventory
file with the configuration and the hosts must be created. Save the
following configuration to a file, i.e. <code>ansible-inventory.txt</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">[OSEv3:children]
masters
nodes

[OSEv3:vars]
deployment_type=origin
openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider', 'filename': '/etc/origin/master/htpasswd'}]
openshift_master_default_subdomain=&lt;yourdomain&gt;
openshift_public_hostname=openshift.&lt;yourdomain&gt;
openshift_hostname=&lt;ec2 instance hostname&gt;
openshift_metrics_hawkular_hostname=hawkular-metrics.&lt;yourdomain&gt;

openshift_install_examples=false
openshift_hosted_metrics_deploy=true

[masters]
&lt;ec2 host&gt; openshift_scheduleable=true openshift_node_labels="{'region': 'infra'}"

[nodes]
&lt;ec2 host&gt; openshift_scheduleable=true openshift_node_labels="{'region': 'infra'}"</pre>
</div>
</div>
<div class="paragraph">
<p>This will configure OpenShift so that it can only be accessed by users
defined in <code>/etc/origin/master/htpasswd</code>.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t have a domain with wildcard support, you can replace with
.nip.io, and you will have a working setup without having a specialized
domain.</p>
</div>
<div class="paragraph">
<p>You can now download the ansible playbooks. The simplest way to do this
is to just clone the git repository:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">git clone https://github.com/openshift/openshift-ansible.git</pre>
</div>
</div>
<div class="paragraph">
<p>To install OpenShift, run the playbook like this</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">ansible-playbook -u ec2-user -b --private-key=&lt;keyfile&gt;.pem -i ansible-inventory.txt openshift-ansible/playbooks/byo/openshift-cluster/config.yml</pre>
</div>
</div>
<div class="paragraph">
<p>This command will take a while to finish.</p>
</div>
</div>
<div class="sect4">
<h5 id="creating-a-user">Creating a user</h5>
<div class="paragraph">
<p>To be able to deploy EnMasse in OpenShift, a user must be created. Log
on to your EC2 instance, and create the user:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">htpasswd -c /etc/origin/master/htpasswd &lt;myuser&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>&lt;myuser&gt;</code> is the username you want to use. The command will
prompt you for a password that you will later use when deploying
EnMasse.</p>
</div>
</div>
<div class="sect4">
<h5 id="installing_enmasse">Installing EnMasse</h5>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
</ol>
</div>
<div class="sect5">
<h6 id="deploying_enmasse_5">Deploying EnMasse</h6>
<div class="paragraph">
<p>Invoke the deployment script to deploy EnMasse</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./deploy-openshift.sh -m "https://openshift.yourdomain:8443" -n enmasse -u myuser</pre>
</div>
</div>
<div class="paragraph">
<p>This will create the deployments required for running EnMasse. Starting
up EnMasse will take a while, usually depending on how fast it is able
to download the docker images for the various components. In the
meantime, you can start to create your address configuration.
followed the above guide, you should have EnMasse deployed. The endpoints will be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>* AMQP: `messaging-enmasse.&lt;yourdomain&gt;`
* MQTT: `mqtt-enmasse.&lt;yourdomain&gt;`
* Console: `console-enmasse.&lt;yourdomain&gt;`</pre>
</div>
</div>
<div class="paragraph">
<p>The console can be used for creating and deleting addresses.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sending-and-receiving-messages-aws">Sending and receiving messages</h5>
<div class="sect6">
<h7 id="connecting_with_amqp_3">Connecting with AMQP</h7>
<div class="paragraph">
<p>For sending and receiving messages, have a look at an example python
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_send.py.html">sender</a>
and
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_recv.py.html">receiver</a>.</p>
</div>
<div class="paragraph">
<p>To send and receive messages, you should connect to the exposed route. To start a receiver, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_recv.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>This will block until it has received 10 messages. To start the sender, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_send.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>The server certificates is not verified in the above examples. To fetch the certificate, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-messaging -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="paragraph">
<p>You can modify the client code to use this cert to verify the server connection.</p>
</div>
<div class="paragraph">
<p>Have a look at <a href="#connecting">Connecting to EnMasse</a> for more client examples.</p>
</div>
</div>
<div class="sect6">
<h7 id="mqtt">Connecting using MQTT</h7>
<div class="paragraph">
<p>For sending and receiving messages route, you can use the paho-mqtt client library. To connect,
fetch the server certificate:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-mqtt  -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="sect7">
<h8 id="subscriber_client_3">Subscriber client</h8>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_recv.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_recv.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe(opts.topic, int(opts.qos))

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic + " " + str(msg.payload))

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Receive messages from the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("recv")
client.on_connect = on_connect
client.on_message = on_message
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to subscribe to a topic (i.e. <code>mytopic</code> from the previous addresses configuration), the
subscriber client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./tls_mqtt_recv.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt</pre>
</div>
</div>
</div>
<div class="sect7">
<h8 id="publisher_client_3">Publisher client</h8>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_send.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_send.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.publish(opts.topic, opts.message, int(opts.qos))

def on_publish(client, userdata, mid):
    print("mid: " + str(mid))
    client.disconnect()

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Sends messages to the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

parser.add_option("-m", "--message", default="Hello",
                  help="message to publish (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("send")
client.on_connect = on_connect
client.on_publish = on_publish
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start the publisher, the client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./tls_mqtt_send.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt -m "Hello EnMasse"</pre>
</div>
</div>
<div class="paragraph">
<p>The the publisher publishes the message and disconnects from EnMasse. The message is received by the previous connected subscriber.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="optional-setting-up-metrics">(Optional) Setting up metrics</h5>
<div class="paragraph">
<p>The process for setting up grafana is a bit more involved, but it gives
you a nice overview of whats going on over time. First of all, I like to
setup everything metric-related in the <code>openshift-infra</code> project. To do
that, you must first give your user permission sufficient privileges. In
this setup, since it&#8217;s not a production setup, I grant cluster-admin
privileges for simplicity (requires logging into the ec2 instance):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>oc adm --config /etc/origin/master/admin.kubeconfig policy add-cluster-role-to-user cluster-admin developer</pre>
</div>
</div>
<div class="paragraph">
<p>With this in place, you can setup the
<a href="https://github.com/hawkular/hawkular-openshift-agent">hawkular-openshift-agent</a>
which pulls metrics from routers and brokers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>oc create -f https://raw.githubusercontent.com/openshift/origin-metrics/master/hawkular-agent/hawkular-openshift-agent-configmap.yaml -n openshift-infra
oc process -f https://raw.githubusercontent.com/openshift/origin-metrics/master/hawkular-agent/hawkular-openshift-agent.yaml IMAGE_VERSION=1.4.0.Final | oc create -n openshift-infra -f -
oc adm policy add-cluster-role-to-user hawkular-openshift-agent system:serviceaccount:openshift-infra:hawkular-openshift-agent</pre>
</div>
</div>
<div class="paragraph">
<p>If everything is setup correctly, you can then deploy
<a href="https://grafana.com/">Grafana</a>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>oc process -f https://raw.githubusercontent.com/hawkular/hawkular-grafana-datasource/master/docker/openshift/openshift-template-ephemeral.yaml -n openshift-infra | oc create -n openshift-infra -f -</pre>
</div>
</div>
<div class="paragraph">
<p>After some time, Grafana should become available at
<code>oc get route -n openshift-infra -o jsonpath='{.spec.host}' hawkular-grafana</code>.
The default username and password is <code>admin/admin</code>. E</p>
</div>
</div>
<div class="sect4">
<h5 id="summary">Summary</h5>
<div class="paragraph">
<p>In this post, you&#8217;ve seen how to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deploy OpenShift on an AWS EC2 instance</p>
</li>
<li>
<p>Deploy EnMasse cloud messaging</p>
</li>
<li>
<p>Deploy Grafana for monitoring</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">EnMasse - Messaging as a Service</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              EnMasse - Messaging as a Service
            
            </li>
            
            <li><a href="mailto:enmasse@redhat.com">enmasse@redhat.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/enmasseproject"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">enmasseproject</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/enmasseio"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">enmasseio</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div class="container" id="companyfooter">
      <div class="redhatlogo" style="text-align:center;">
          <div id="logospacer"></div>
          <a href="http://www.redhat.com/"><img alt="Red Hat" src="http://static.jboss.org/images/rhbar/redhatlogo.png"></a>
      </div>
    </div>
  </body>

</html>
