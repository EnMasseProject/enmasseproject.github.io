<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Getting Started</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://enmasse.io/documentation/master/getting_started/">
  <link rel="alternate" type="application/rss+xml" title="EnMasse - Messaging as a Service" href="/feed.xml">
  
  
</head>


  <body>
    <div id="rhbar" style="height:40px;background-color: #202020">
        <a class="rhd-logo" href="http://developers.redhat.com" style="float: right;background-image: url(http://static.jboss.org/images/rhbar/rhd_reverse.png);background-repeat: no-repeat;height: 40px;width: 136px;"></a>
        <a class="rhlogo" href="http://www.redhat.com/" style="float: right;background-image: url(http://static.jboss.org/images/rhbar/redhatlogo_reverse.png);background-repeat: no-repeat;height: 40px;width: 85px;"></a>
    </div>


    <div align="center">
    <br />
    <img alt="EnMasse"
    src="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/images/logo/enmasse_logo.png" height="30%" width="30%" />
</div>
<br />
<br />
<center>
<header align="center" style="align: center;">
  <nav>
    
    

<a href="/" title="Go to Overview">Overview</a> 

 |


<a href="/documentation" title="Go to Documentation">Documentation</a> 

 |


<a href="https://github.com/EnMasseProject/enmasse/releases/" title="Go to Downloads">Downloads</a> 

 |


<a href="/contributing" title="Go to Contributing">Contributing</a> 




  </nav>
</header>
</center>



    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h2> Documentation for EnMasse master </h2>
        <header align="left">
  <nav>
    
    
  <a href="/documentation/master/getting_started" title="Go to Getting Started">Getting Started</a><br />

  <a href="/documentation/master/service_admin" title="Go to Installation and configuration">Installation and configuration</a><br />

  <a href="/documentation/master/tenant" title="Go to Managing address spaces and addresses">Managing address spaces and addresses</a><br />

  <a href="/documentation/master/messaging_app_developer" title="Go to Connecting applications to EnMasse">Connecting applications to EnMasse</a><br />


  </nav>
</header>

        <br />
        <h3> Getting Started </h3>
        <br />
        <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#enmasse-on-openshift">1. EnMasse on OpenShift</a>
<ul class="sectlevel3">
<li><a href="#prerequisites-openshift">1.1. Prerequisites</a></li>
<li><a href="#installing-openshift">1.2. Installing EnMasse</a>
<ul class="sectlevel4">
<li><a href="#deploying_enmasse">Deploying EnMasse</a></li>
</ul>
</li>
<li><a href="#configuring-addresses-openshift">1.3. Configuring addresses</a>
<ul class="sectlevel5">
<li><a href="#address_types">Address types</a></li>
</ul>
</li>
<li><a href="#sending-and-receiving-messages-openshift">1.4. Sending and receiving messages</a>
<ul class="sectlevel5">
<li><a href="#connecting_with_amqp">Connecting with AMQP</a></li>
<li><a href="#mqtt">Connecting using MQTT</a></li>
</ul>
</li>
<li><a href="#conclusion-openshift">1.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#enmasse-on-kubernetes">2. EnMasse on Kubernetes</a>
<ul class="sectlevel3">
<li><a href="#prerequisites-kubernetes">2.1. Prerequisites</a></li>
<li><a href="#installing-kubernetes">2.2. Installing</a>
<ul class="sectlevel4">
<li><a href="#deploying_enmasse_2">Deploying EnMasse</a></li>
<li><a href="#role-based-access-control">Role Based Access Control (RBAC)</a></li>
</ul>
</li>
<li><a href="#deploying-external-load-balancers">2.3. Deploying external load balancers</a></li>
<li><a href="#configuring-addresses-kubernetes">2.4. Configuring addresses</a>
<ul class="sectlevel5">
<li><a href="#address_types_2">Address types</a></li>
</ul>
</li>
<li><a href="#sending-and-receiving-messages-kubernetes">2.5. Sending and receiving messages</a>
<ul class="sectlevel5">
<li><a href="#connecting_with_amqp_2">Connecting with AMQP</a></li>
<li><a href="#mqtt">Connecting using MQTT</a></li>
</ul>
</li>
<li><a href="#conclusion-kubernetes">2.6. Conclusion</a></li>
</ul>
</li>
<li><a href="#setting-up-enmasse-on-aws">3. Setting up EnMasse on AWS</a>
<ul class="sectlevel2">
<li><a href="#prerequisites-aws">3.1. Prerequisites</a>
<ul class="sectlevel3">
<li><a href="#configure-ansible-to-handle-passwordless-sudo">3.1.1. Configure Ansible to handle passwordless sudo</a></li>
</ul>
</li>
<li><a href="#setting-up-openshift-aws">3.2. Setting up OpenShift</a>
<ul class="sectlevel3">
<li><a href="#creating-a-user">3.2.1. Creating a user</a></li>
</ul>
</li>
<li><a href="#installing_enmasse">3.3. Installing EnMasse</a>
<ul class="sectlevel4">
<li><a href="#deploying_enmasse_3">Deploying EnMasse</a></li>
<li><a href="#sending-and-receiving-messages-aws">3.3.2. Sending and receiving messages</a>
<ul class="sectlevel5">
<li><a href="#connecting_with_amqp_3">Connecting with AMQP</a></li>
<li><a href="#mqtt">Connecting using MQTT</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#optional-setting-up-metrics">3.4. (Optional) Setting up metrics</a></li>
<li><a href="#summary">3.5. Summary</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="enmasse-on-openshift">1. EnMasse on OpenShift</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide will walk through the process of setting up EnMasse on
OpenShift with clients for sending and receiving messages.</p>
</div>
<div class="sect3">
<h4 id="prerequisites-openshift">1.1. Prerequisites</h4>
<div class="paragraph">
<p>To install EnMasse, you need to have the OpenShift client tools. You can download the OpenShift
Origin client from <a href="https://github.com/openshift/origin/releases">OpenShift Origin</a>. EnMasse has
been tested to work with the latest stable release of the OpenShift Origin Client.</p>
</div>
<div class="paragraph">
<p>If you do not have an OpenShift cluster available, see
<a href="https://github.com/minishift/minishift">minishift</a> for an example of how to run a local instance of OpenShift
on your machine.</p>
</div>
</div>
<div class="sect3">
<h4 id="installing-openshift">1.2. Installing EnMasse</h4>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
<li>
<p>Deploy EnMasse using the deployment script provided in the release.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can invoke the deployment script with <code>-h</code> to view a list of options.</p>
</div>
<div class="sect4">
<h5 id="deploying_enmasse">Deploying EnMasse</h5>
<div class="paragraph">
<p>Invoke the deployment script to deploy EnMasse</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./deploy-openshift.sh -m "https://localhost:8443" -n enmasse </pre>
</div>
</div>
<div class="paragraph">
<p>This will create the deployments required for running EnMasse. Starting
up EnMasse will take a while, usually depending on how fast it is able
to download the docker images for the various components. In the
meantime, you can start to create your address configuration.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-addresses-openshift">1.3. Configuring addresses</h4>
<div class="sect5">
<h6 id="address_types">Address types</h6>
<div class="paragraph">
<p>EnMasse is configured with a set of addresses that you can use for
messages. Currently, EnMasse supports 4 different address types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Brokered queues</p>
</li>
<li>
<p>Brokered topics (pub/sub)</p>
</li>
<li>
<p>Direct anycast addresses</p>
</li>
<li>
<p>Direct broadcast addresses</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="common/address-model.adoc">address model</a> for details.
EnMasse also comes with a console that you can use for managing
addresses. You can get the console URL by running the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">echo "https://$(oc get route -o jsonpath='{.spec.host}' console)"</pre>
</div>
</div>
<div class="paragraph">
<p>You can also deploy the addressing config using the address controller
API. See the <a href="common/configuring-using-restapi.adoc">restapi documentation</a> for details on the
resources consumed by the API. Here is an example config with all 4 variants that you can save to <code>addresses.json</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">{
  "apiVersion": "enmasse.io/v1",
  "kind": "AddressList",
  "items": [
    {
      "metadata": {
        "name": "myqueue"
      },
      "spec": {
        "type": "queue"
      }
    },
    {
      "metadata": {
        "name": "mytopic"
      },
      "spec": {
        "type": "topic"
      }
    },
    {
      "metadata": {
        "name": "myanycast"
      },
      "spec": {
        "type": "anycast"
      }
    },
    {
      "metadata": {
        "name": "mymulticast"
      },
      "spec": {
        "type": "multicast"
      }
    }
  ]
}</pre>
</div>
</div>
<div class="paragraph">
<p>To deploy this configuration, you must currently use a http client like curl:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">curl -X POST -H "content-type: application/json" --data-binary @addresses.json -k https://$(oc get route -o jsonpath='{.spec.host}' restapi)/apis/enmasse.io/v1/addresses/default</pre>
</div>
</div>
<div class="paragraph">
<p>This will connect to the address controller REST API and deploy the address config.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sending-and-receiving-messages-openshift">1.4. Sending and receiving messages</h4>
<div class="sect5">
<h6 id="connecting_with_amqp">Connecting with AMQP</h6>
<div class="paragraph">
<p>For sending and receiving messages, have a look at an example python
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_send.py.html">sender</a>
and
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_recv.py.html">receiver</a>.</p>
</div>
<div class="paragraph">
<p>To send and receive messages, you should connect to the exposed route. To start a receiver, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_recv.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>This will block until it has received 10 messages. To start the sender, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_send.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>The server certificates is not verified in the above examples. To fetch the certificate, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-messaging -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="paragraph">
<p>You can modify the client code to use this cert to verify the server connection.</p>
</div>
<div class="paragraph">
<p>Have a look at <a href="http://enmasse.io/documentation/master/messaging_app_developer/#connecting">connecting
to EnMasse</a> for more client examples.</p>
</div>
</div>
<div class="sect5">
<h6 id="mqtt">Connecting using MQTT</h6>
<div class="paragraph">
<p>For sending and receiving messages route, you can use the paho-mqtt client library. To connect,
fetch the server certificate:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-mqtt  -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="sect6">
<h7 id="subscriber_client">Subscriber client</h7>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_recv.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_recv.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe(opts.topic, int(opts.qos))

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic + " " + str(msg.payload))

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Receive messages from the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("recv")
client.on_connect = on_connect
client.on_message = on_message
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to subscribe to a topic (i.e. <code>mytopic</code> from the previous addresses configuration), the
subscriber client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./tls_mqtt_recv.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt</pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="publisher_client">Publisher client</h7>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_send.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_send.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.publish(opts.topic, opts.message, int(opts.qos))

def on_publish(client, userdata, mid):
    print("mid: " + str(mid))
    client.disconnect()

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Sends messages to the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

parser.add_option("-m", "--message", default="Hello",
                  help="message to publish (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("send")
client.on_connect = on_connect
client.on_publish = on_publish
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start the publisher, the client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./tls_mqtt_send.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt -m "Hello EnMasse"</pre>
</div>
</div>
<div class="paragraph">
<p>The the publisher publishes the message and disconnects from EnMasse. The message is received by the previous connected subscriber.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conclusion-openshift">1.5. Conclusion</h3>
<div class="paragraph">
<p>We have seen how to setup EnMasse on OpenShift, and how to communicate with it using AMQP and MQTT clients.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="enmasse-on-kubernetes">2. EnMasse on Kubernetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide will walk through the process of setting up EnMasse on a
Kubernetes cluster together with clients for sending and receiving
messages.</p>
</div>
<div class="sect3">
<h4 id="prerequisites-kubernetes">2.1. Prerequisites</h4>
<div class="paragraph">
<p>To install EnMasse, you need to have Kubernetes installed. You can use
<a href="https://github.com/kubernetes/minikube">minikube</a> if you want to install EnMasse on your
laptop.</p>
</div>
</div>
<div class="sect3">
<h4 id="installing-kubernetes">2.2. Installing</h4>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
<li>
<p>Deploy EnMasse using the deployment script provided in the release.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can invoke the deployment script with <code>-h</code> to view a list of options.</p>
</div>
<div class="sect4">
<h5 id="deploying_enmasse_2">Deploying EnMasse</h5>
<div class="paragraph">
<p>Invoke the deployment script to deploy EnMasse</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./deploy-kubernetes.sh -m "https://localhost:8443" -n enmasse </pre>
</div>
</div>
<div class="paragraph">
<p>This will create the deployments required for running EnMasse. Starting
up EnMasse will take a while, usually depending on how fast it is able
to download the docker images for the various components. In the
meantime, you can start to create your address configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="role-based-access-control">Role Based Access Control (RBAC)</h5>
<div class="paragraph">
<p>The Kubernetes deployment script and YAML files currently do not support Role
Based Access Control (RBAC). In Kubernetes clusters which have RBAC enabled, it is
required to additionally create a role binding for the <code>default</code> service account
to the <code>view</code> role and for the <code>enmasse-service-account</code> to the <code>cluster-admin</code> role:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">kubectl create clusterrolebinding enmasse-service-account-binding --clusterrole=cluster-admin --serviceaccount=enmasse:enmasse-service-account
kubectl create rolebinding default-view-binding --clusterrole=view --serviceaccount=enmasse:default -n enmasse</pre>
</div>
</div>
<div class="paragraph">
<p><em>Note: The <code>cluster-admin</code> role gives the <code>enmasse-service-account</code> service account unlimited access to the Kubernetes cluster.</em></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="deploying-external-load-balancers">2.3. Deploying external load balancers</h4>
<div class="paragraph">
<p>If you&#8217;re running EnMasse in your own Kubernetes instance on any of the
cloud providers, you can deploy the external load balancer services
to expose EnMasse ports:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">kubectl apply -f kubernetes/addons/external-lb.yaml -n enmasse</pre>
</div>
</div>
<div class="paragraph">
<p>If you are running in multitenant mode, exposing the restapi is sufficient:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">kubectl apply -f kubernetes/addons/external-lb-restapi.yaml -n enmasse</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-addresses-kubernetes">2.4. Configuring addresses</h4>
<div class="sect5">
<h6 id="address_types_2">Address types</h6>
<div class="paragraph">
<p>EnMasse is configured with a set of addresses that you can use for
messages. Currently, EnMasse supports 4 different address types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Brokered queues</p>
</li>
<li>
<p>Brokered topics (pub/sub)</p>
</li>
<li>
<p>Direct anycast addresses</p>
</li>
<li>
<p>Direct broadcast addresses</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="common/address-model.adoc">address model</a> for details.
EnMasse also comes with a console that you can use for managing
addresses. You can get the console URL by running the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">echo "https://$(kubectl get ingress -o jsonpath='{.spec.host}' console)"</pre>
</div>
</div>
<div class="paragraph">
<p>You can also deploy the addressing config using the address controller
API. See the <a href="common/configuring-using-restapi.adoc">restapi documentation</a> for details on the
resources consumed by the API. Here is an example config with all 4 variants that you can save to <code>addresses.json</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">{
  "apiVersion": "enmasse.io/v1",
  "kind": "AddressList",
  "items": [
    {
      "metadata": {
        "name": "myqueue"
      },
      "spec": {
        "type": "queue"
      }
    },
    {
      "metadata": {
        "name": "mytopic"
      },
      "spec": {
        "type": "topic"
      }
    },
    {
      "metadata": {
        "name": "myanycast"
      },
      "spec": {
        "type": "anycast"
      }
    },
    {
      "metadata": {
        "name": "mymulticast"
      },
      "spec": {
        "type": "multicast"
      }
    }
  ]
}</pre>
</div>
</div>
<div class="paragraph">
<p>To deploy this configuration, you must currently use a http client like curl:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">curl -X POST -H "content-type: application/json" --data-binary @addresses.json -k https://$(kubectl get ingress -o jsonpath='{.spec.host}' restapi)/apis/enmasse.io/v1/addresses/default</pre>
</div>
</div>
<div class="paragraph">
<p>This will connect to the address controller REST API and deploy the address config.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sending-and-receiving-messages-kubernetes">2.5. Sending and receiving messages</h4>
<div class="sect5">
<h6 id="connecting_with_amqp_2">Connecting with AMQP</h6>
<div class="paragraph">
<p>For sending and receiving messages, have a look at an example python
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_send.py.html">sender</a>
and
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_recv.py.html">receiver</a>.</p>
</div>
<div class="paragraph">
<p>To send and receive messages, you should connect to the exposed route. To start a receiver, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_recv.py -a "amqps://$(kubectl get ingress -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>This will block until it has received 10 messages. To start the sender, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_send.py -a "amqps://$(kubectl get ingress -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>The server certificates is not verified in the above examples. To fetch the certificate, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
kubectl get secret external-certs-messaging -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="paragraph">
<p>You can modify the client code to use this cert to verify the server connection.</p>
</div>
<div class="paragraph">
<p>Have a look at <a href="http://enmasse.io/documentation/master/messaging_app_developer/#connecting">connecting
to EnMasse</a> for more client examples.</p>
</div>
</div>
<div class="sect5">
<h6 id="mqtt">Connecting using MQTT</h6>
<div class="paragraph">
<p>For sending and receiving messages route, you can use the paho-mqtt client library. To connect,
fetch the server certificate:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
kubectl get secret external-certs-mqtt  -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="sect6">
<h7 id="subscriber_client_2">Subscriber client</h7>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_recv.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_recv.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe(opts.topic, int(opts.qos))

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic + " " + str(msg.payload))

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Receive messages from the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("recv")
client.on_connect = on_connect
client.on_message = on_message
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to subscribe to a topic (i.e. <code>mytopic</code> from the previous addresses configuration), the
subscriber client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./tls_mqtt_recv.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt</pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="publisher_client_2">Publisher client</h7>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_send.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_send.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.publish(opts.topic, opts.message, int(opts.qos))

def on_publish(client, userdata, mid):
    print("mid: " + str(mid))
    client.disconnect()

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Sends messages to the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

parser.add_option("-m", "--message", default="Hello",
                  help="message to publish (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("send")
client.on_connect = on_connect
client.on_publish = on_publish
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start the publisher, the client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./tls_mqtt_send.py -c "$(kubectl get ingress -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt -m "Hello EnMasse"</pre>
</div>
</div>
<div class="paragraph">
<p>The the publisher publishes the message and disconnects from EnMasse. The message is received by the previous connected subscriber.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conclusion-kubernetes">2.6. Conclusion</h3>
<div class="paragraph">
<p>We have seen how to setup a messaging service in Kubernetes, and how to
communicate with it using python example AMQP clients.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-up-enmasse-on-aws">3. Setting up EnMasse on AWS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide walks you through setting up EnMasse on an AWS EC2 instance.
This is not even very specific to AWS, so you can probably modify the
configuration to fit Microsoft Azure or even Google GCE.</p>
</div>
<div class="paragraph">
<p>The end result from this guide is an instance of EnMasse suitable for
development and/or experimentation, and should not be considered a
production ready setup. For instance, no persistence is configured, so
neither messages in brokers nor state in other components like hawkular
are persisted.</p>
</div>
<div class="sect2">
<h3 id="prerequisites-aws">3.1. Prerequisites</h3>
<div class="paragraph">
<p>First, you must have created an <a href="https://aws.amazon.com/ec2/">EC2
instance</a>. EnMasse runs on OpenShift and Kubernetes, but this post uses
OpenShift purely for convenience. Have a look at the
<a href="https://docs.openshift.org/latest/install_config/install/prerequisites.html">OpenShift
prerequisites</a> for the required hardware configuration. The installation
will be done using <a href="https://www.ansible.com">Ansible</a>, so make sure
Ansible is installed on laptop or workstation.</p>
</div>
<div class="sect3">
<h4 id="configure-ansible-to-handle-passwordless-sudo">3.1.1. Configure Ansible to handle passwordless sudo</h4>
<div class="paragraph">
<p>For EC2 instance, the default is a passwordless sudo, and Ansible
(2.3.0.0 at the time of writing) requires a minor configuration
modification to deal with that. On the host you will be running ansible
from, edit /etc/ansible/ansible.cfg, and make sure that the <code>sudo_flags</code>
parameter is set to <code>-H -S</code> (remove the <code>-n</code>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="setting-up-openshift-aws">3.2. Setting up OpenShift</h3>
<div class="paragraph">
<p>Once Ansible is setup, installing OpenShift is easy. First, an inventory
file with the configuration and the hosts must be created. Save the
following configuration to a file, i.e. <code>ansible-inventory.txt</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">[OSEv3:children]
masters
nodes

[OSEv3:vars]
deployment_type=origin
openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider', 'filename': '/etc/origin/master/htpasswd'}]
openshift_master_default_subdomain=&lt;yourdomain&gt;
openshift_public_hostname=openshift.&lt;yourdomain&gt;
openshift_hostname=&lt;ec2 instance hostname&gt;
openshift_metrics_hawkular_hostname=hawkular-metrics.&lt;yourdomain&gt;

openshift_install_examples=false
openshift_hosted_metrics_deploy=true

[masters]
&lt;ec2 host&gt; openshift_scheduleable=true openshift_node_labels="{'region': 'infra'}"

[nodes]
&lt;ec2 host&gt; openshift_scheduleable=true openshift_node_labels="{'region': 'infra'}"</pre>
</div>
</div>
<div class="paragraph">
<p>This will configure OpenShift so that it can only be accessed by users
defined in <code>/etc/origin/master/htpasswd</code>.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t have a domain with wildcard support, you can replace with
.nip.io, and you will have a working setup without having a specialized
domain.</p>
</div>
<div class="paragraph">
<p>You can now download the ansible playbooks. The simplest way to do this
is to just clone the git repository:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">git clone https://github.com/openshift/openshift-ansible.git</pre>
</div>
</div>
<div class="paragraph">
<p>To install OpenShift, run the playbook like this</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">ansible-playbook -u ec2-user -b --private-key=&lt;keyfile&gt;.pem -i ansible-inventory.txt openshift-ansible/playbooks/byo/openshift-cluster/config.yml</pre>
</div>
</div>
<div class="paragraph">
<p>This command will take a while to finish.</p>
</div>
<div class="sect3">
<h4 id="creating-a-user">3.2.1. Creating a user</h4>
<div class="paragraph">
<p>To be able to deploy EnMasse in OpenShift, a user must be created. Log
on to your EC2 instance, and create the user:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">htpasswd -c /etc/origin/master/htpasswd &lt;myuser&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>&lt;myuser&gt;</code> is the username you want to use. The command will
prompt you for a password that you will later use when deploying
EnMasse.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="installing_enmasse">3.3. Installing EnMasse</h3>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download one of the releases from <a href="https://github.com/EnMasseProject/enmasse/releases" class="bare">https://github.com/EnMasseProject/enmasse/releases</a> and unpack it.</p>
</li>
<li>
<p>Deploy EnMasse using the deployment script provided in the release.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can invoke the deployment script with <code>-h</code> to view a list of options.</p>
</div>
<div class="sect4">
<h5 id="deploying_enmasse_3">Deploying EnMasse</h5>
<div class="paragraph">
<p>Invoke the deployment script to deploy EnMasse</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./deploy-openshift.sh -m "https://openshift.yourdomain:8443" -n enmasse -u myuser</pre>
</div>
</div>
<div class="paragraph">
<p>This will create the deployments required for running EnMasse. Starting
up EnMasse will take a while, usually depending on how fast it is able
to download the docker images for the various components. In the
meantime, you can start to create your address configuration.
followed the above guide, you should have EnMasse deployed. The endpoints will be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>* AMQP: `messaging-enmasse.&lt;yourdomain&gt;`
* MQTT: `mqtt-enmasse.&lt;yourdomain&gt;`
* Console: `console-enmasse.&lt;yourdomain&gt;`</pre>
</div>
</div>
<div class="paragraph">
<p>The console can be used for creating and deleting addresses.</p>
</div>
</div>
<div class="sect3">
<h4 id="sending-and-receiving-messages-aws">3.3.2. Sending and receiving messages</h4>
<div class="sect5">
<h6 id="connecting_with_amqp_3">Connecting with AMQP</h6>
<div class="paragraph">
<p>For sending and receiving messages, have a look at an example python
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_send.py.html">sender</a>
and
<a href="http://qpid.apache.org/releases/qpid-proton-0.18.0/proton/python/examples/simple_recv.py.html">receiver</a>.</p>
</div>
<div class="paragraph">
<p>To send and receive messages, you should connect to the exposed route. To start a receiver, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_recv.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>This will block until it has received 10 messages. To start the sender, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./simple_send.py -a "amqps://$(oc get route -o jsonpath='{.spec.host}' messaging):443/anycast" -m 10</pre>
</div>
</div>
<div class="paragraph">
<p>The server certificates is not verified in the above examples. To fetch the certificate, run:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-messaging -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="paragraph">
<p>You can modify the client code to use this cert to verify the server connection.</p>
</div>
<div class="paragraph">
<p>Have a look at <a href="http://enmasse.io/documentation/master/messaging_app_developer/#connecting">connecting
to EnMasse</a> for more client examples.</p>
</div>
</div>
<div class="sect5">
<h6 id="mqtt">Connecting using MQTT</h6>
<div class="paragraph">
<p>For sending and receiving messages route, you can use the paho-mqtt client library. To connect,
fetch the server certificate:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">mkdir -p certs
oc get secret external-certs-mqtt  -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; certs/tls.crt</pre>
</div>
</div>
<div class="sect6">
<h7 id="subscriber_client_3">Subscriber client</h7>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_recv.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_recv.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.subscribe(opts.topic, int(opts.qos))

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic + " " + str(msg.payload))

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Receive messages from the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("recv")
client.on_connect = on_connect
client.on_message = on_message
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to subscribe to a topic (i.e. <code>mytopic</code> from the previous addresses configuration), the
subscriber client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./tls_mqtt_recv.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt</pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="publisher_client_3">Publisher client</h7>
<div class="paragraph">
<p>Save the following to <code>tls_mqtt_send.py</code> or <a href="https://raw.githubusercontent.com/EnMasseProject/enmasse/master/documentation/design_docs/examples/tls_mqtt_send.py">download</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code>#!/usr/bin/env python

import paho.mqtt.client as mqtt
import ssl
import optparse

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    client.publish(opts.topic, opts.message, int(opts.qos))

def on_publish(client, userdata, mid):
    print("mid: " + str(mid))
    client.disconnect()

def on_log(client, userdata, level, string):
    print(string)

parser = optparse.OptionParser(usage="usage: %prog [options]",
                               description="Sends messages to the supplied address.")

parser.add_option("-c", "--connectHost", default="localhost",
                  help="host to connect to (default %default)")

parser.add_option("-p", "--portHost", default="8883",
                  help="port to connect to (default %default)")

parser.add_option("-t", "--topic", default="mytopic",
                  help="topic to subscribe to (default %default)")

parser.add_option("-q", "--qos", default="0",
                  help="quality of service (default %default)")

parser.add_option("-s", "--serverCert", default=None,
                  help="server certificate file path (default %default)")

parser.add_option("-m", "--message", default="Hello",
                  help="message to publish (default %default)")

opts, args = parser.parse_args()

client = mqtt.Client("send")
client.on_connect = on_connect
client.on_publish = on_publish
client.on_log = on_log

context = ssl.create_default_context()
if opts.serverCert == None:
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
else:
    context.load_verify_locations(cafile=opts.serverCert)

# just useful to activate for decrypting local TLS traffic with Wireshark
#context.set_ciphers("RSA")

client.tls_set_context(context)
client.tls_insecure_set(True)
client.connect(opts.connectHost, opts.portHost, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start the publisher, the client can be used in the following way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre class="nowrap">./tls_mqtt_send.py -c "$(oc get route -o jsonpath='{.spec.host}' mqtt)" -p 443 -t mytopic -q 1 -s ./certs/tls.crt -m "Hello EnMasse"</pre>
</div>
</div>
<div class="paragraph">
<p>The the publisher publishes the message and disconnects from EnMasse. The message is received by the previous connected subscriber.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="optional-setting-up-metrics">3.4. (Optional) Setting up metrics</h3>
<div class="paragraph">
<p>The process for setting up grafana is a bit more involved, but it gives
you a nice overview of whats going on over time. First of all, I like to
setup everything metric-related in the <code>openshift-infra</code> project. To do
that, you must first give your user permission sufficient privileges. In
this setup, since it&#8217;s not a production setup, I grant cluster-admin
privileges for simplicity (requires logging into the ec2 instance):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>oc adm --config /etc/origin/master/admin.kubeconfig policy add-cluster-role-to-user cluster-admin developer</pre>
</div>
</div>
<div class="paragraph">
<p>With this in place, you can setup the
<a href="https://github.com/hawkular/hawkular-openshift-agent">hawkular-openshift-agent</a>
which pulls metrics from routers and brokers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>oc create -f https://raw.githubusercontent.com/openshift/origin-metrics/master/hawkular-agent/hawkular-openshift-agent-configmap.yaml -n openshift-infra
oc process -f https://raw.githubusercontent.com/openshift/origin-metrics/master/hawkular-agent/hawkular-openshift-agent.yaml IMAGE_VERSION=1.4.0.Final | oc create -n openshift-infra -f -
oc adm policy add-cluster-role-to-user hawkular-openshift-agent system:serviceaccount:openshift-infra:hawkular-openshift-agent</pre>
</div>
</div>
<div class="paragraph">
<p>If everything is setup correctly, you can then deploy
<a href="https://grafana.com/">Grafana</a>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>oc process -f https://raw.githubusercontent.com/hawkular/hawkular-grafana-datasource/master/docker/openshift/openshift-template-ephemeral.yaml -n openshift-infra | oc create -n openshift-infra -f -</pre>
</div>
</div>
<div class="paragraph">
<p>After some time, Grafana should become available at
<code>oc get route -n openshift-infra -o jsonpath='{.spec.host}' hawkular-grafana</code>.
The default username and password is <code>admin/admin</code>. E</p>
</div>
</div>
<div class="sect2">
<h3 id="summary">3.5. Summary</h3>
<div class="paragraph">
<p>In this post, you&#8217;ve seen how to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deploy OpenShift on an AWS EC2 instance</p>
</li>
<li>
<p>Deploy EnMasse cloud messaging</p>
</li>
<li>
<p>Deploy Grafana for monitoring</p>
</li>
</ul>
</div>
</div>
</div>
</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">EnMasse - Messaging as a Service</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              EnMasse - Messaging as a Service
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div class="container" id="companyfooter">
      <div class="redhatlogo" style="text-align:center;">
          <div id="logospacer"></div>
          <a href="http://www.redhat.com/"><img alt="Red Hat" src="http://static.jboss.org/images/rhbar/redhatlogo.png"></a>
      </div>
    </div>
  </body>

</html>
